// automatically generated by the FlatBuffers compiler, do not modify

#![allow(dead_code)]
#![allow(unused_imports)]

pub mod rlbot {
    #![allow(dead_code)]
    #![allow(unused_imports)]

    use std::{cmp::Ordering, mem};

    use self::flatbuffers::EndianScalar;
    use flatbuffers;
    pub mod flat {
        #![allow(dead_code)]
        #![allow(unused_imports)]

        use std::{cmp::Ordering, mem};

        use self::flatbuffers::EndianScalar;
        use flatbuffers;

        #[allow(non_camel_case_types)]
        #[repr(u8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum CollisionShape {
            NONE = 0,
            BoxShape = 1,
            SphereShape = 2,
            CylinderShape = 3,
        }

        const ENUM_MIN_COLLISION_SHAPE: u8 = 0;
        const ENUM_MAX_COLLISION_SHAPE: u8 = 3;

        impl<'a> flatbuffers::Follow<'a> for CollisionShape {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for CollisionShape {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = u8::to_le(self as u8);
                let p = &n as *const u8 as *const CollisionShape;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = u8::from_le(self as u8);
                let p = &n as *const u8 as *const CollisionShape;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for CollisionShape {
            type Output = CollisionShape;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<CollisionShape>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_COLLISION_SHAPE: [CollisionShape; 4] = [
            CollisionShape::NONE,
            CollisionShape::BoxShape,
            CollisionShape::SphereShape,
            CollisionShape::CylinderShape,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_COLLISION_SHAPE: [&'static str; 4] =
            ["NONE", "BoxShape", "SphereShape", "CylinderShape"];

        pub fn enum_name_collision_shape(e: CollisionShape) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_COLLISION_SHAPE[index]
        }

        pub struct CollisionShapeUnionTableOffset {}
        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum TileState {
            Unknown = 0,
            /// The default state of the tiles.
            Filled = 1,
            /// The state when a tile has been damaged.
            Damaged = 2,
            /// The state of a tile when it is open and a goal can be scored.
            Open = 3,
        }

        const ENUM_MIN_TILE_STATE: i8 = 0;
        const ENUM_MAX_TILE_STATE: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for TileState {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for TileState {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const TileState;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const TileState;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for TileState {
            type Output = TileState;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<TileState>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_TILE_STATE: [TileState; 4] = [
            TileState::Unknown,
            TileState::Filled,
            TileState::Damaged,
            TileState::Open,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_TILE_STATE: [&'static str; 4] = ["Unknown", "Filled", "Damaged", "Open"];

        pub fn enum_name_tile_state(e: TileState) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_TILE_STATE[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum RenderType {
            DrawLine2D = 1,
            DrawLine3D = 2,
            DrawLine2D_3D = 3,
            DrawRect2D = 4,
            DrawRect3D = 5,
            DrawString2D = 6,
            DrawString3D = 7,
            DrawCenteredRect3D = 8,
        }

        const ENUM_MIN_RENDER_TYPE: i8 = 1;
        const ENUM_MAX_RENDER_TYPE: i8 = 8;

        impl<'a> flatbuffers::Follow<'a> for RenderType {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for RenderType {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const RenderType;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const RenderType;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for RenderType {
            type Output = RenderType;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<RenderType>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_RENDER_TYPE: [RenderType; 8] = [
            RenderType::DrawLine2D,
            RenderType::DrawLine3D,
            RenderType::DrawLine2D_3D,
            RenderType::DrawRect2D,
            RenderType::DrawRect3D,
            RenderType::DrawString2D,
            RenderType::DrawString3D,
            RenderType::DrawCenteredRect3D,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_RENDER_TYPE: [&'static str; 8] = [
            "DrawLine2D",
            "DrawLine3D",
            "DrawLine2D_3D",
            "DrawRect2D",
            "DrawRect3D",
            "DrawString2D",
            "DrawString3D",
            "DrawCenteredRect3D",
        ];

        pub fn enum_name_render_type(e: RenderType) -> &'static str {
            let index: usize = e as usize - RenderType::DrawLine2D as usize;
            ENUM_NAMES_RENDER_TYPE[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum QuickChatSelection {
            Information_IGotIt = 0,
            Information_NeedBoost = 1,
            Information_TakeTheShot = 2,
            Information_Defending = 3,
            Information_GoForIt = 4,
            Information_Centering = 5,
            Information_AllYours = 6,
            Information_InPosition = 7,
            Information_Incoming = 8,
            Compliments_NiceShot = 9,
            Compliments_GreatPass = 10,
            Compliments_Thanks = 11,
            Compliments_WhatASave = 12,
            Compliments_NiceOne = 13,
            Compliments_WhatAPlay = 14,
            Compliments_GreatClear = 15,
            Compliments_NiceBlock = 16,
            Reactions_OMG = 17,
            Reactions_Noooo = 18,
            Reactions_Wow = 19,
            Reactions_CloseOne = 20,
            Reactions_NoWay = 21,
            Reactions_HolyCow = 22,
            Reactions_Whew = 23,
            Reactions_Siiiick = 24,
            Reactions_Calculated = 25,
            Reactions_Savage = 26,
            Reactions_Okay = 27,
            Apologies_Cursing = 28,
            Apologies_NoProblem = 29,
            Apologies_Whoops = 30,
            Apologies_Sorry = 31,
            Apologies_MyBad = 32,
            Apologies_Oops = 33,
            Apologies_MyFault = 34,
            PostGame_Gg = 35,
            PostGame_WellPlayed = 36,
            PostGame_ThatWasFun = 37,
            PostGame_Rematch = 38,
            PostGame_OneMoreGame = 39,
            PostGame_WhatAGame = 40,
            PostGame_NiceMoves = 41,
            PostGame_EverybodyDance = 42,
            /// Custom text chats made by bot makers
            MaxPysonixQuickChatPresets = 43,
            /// Waste of CPU cycles
            Custom_Toxic_WasteCPU = 44,
            /// Git gud*
            Custom_Toxic_GitGut = 45,
            /// De-Allocate Yourself
            Custom_Toxic_DeAlloc = 46,
            /// 404: Your skill not found
            Custom_Toxic_404NoSkill = 47,
            /// Get a virus
            Custom_Toxic_CatchVirus = 48,
            /// Passing!
            Custom_Useful_Passing = 49,
            /// Faking!
            Custom_Useful_Faking = 50,
            /// Demoing!
            Custom_Useful_Demoing = 51,
            /// BOOPING
            Custom_Useful_Bumping = 52,
            /// The chances of that was 47525 to 1*
            Custom_Compliments_TinyChances = 53,
            /// Who upped your skill level?
            Custom_Compliments_SkillLevel = 54,
            /// Your programmer should be proud
            Custom_Compliments_proud = 55,
            /// You're the GC of Bots
            Custom_Compliments_GC = 56,
            /// Are you <Insert Pro>Bot? *
            Custom_Compliments_Pro = 57,
        }

        const ENUM_MIN_QUICK_CHAT_SELECTION: i8 = 0;
        const ENUM_MAX_QUICK_CHAT_SELECTION: i8 = 57;

        impl<'a> flatbuffers::Follow<'a> for QuickChatSelection {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for QuickChatSelection {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const QuickChatSelection;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const QuickChatSelection;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for QuickChatSelection {
            type Output = QuickChatSelection;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<QuickChatSelection>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_QUICK_CHAT_SELECTION: [QuickChatSelection; 58] = [
            QuickChatSelection::Information_IGotIt,
            QuickChatSelection::Information_NeedBoost,
            QuickChatSelection::Information_TakeTheShot,
            QuickChatSelection::Information_Defending,
            QuickChatSelection::Information_GoForIt,
            QuickChatSelection::Information_Centering,
            QuickChatSelection::Information_AllYours,
            QuickChatSelection::Information_InPosition,
            QuickChatSelection::Information_Incoming,
            QuickChatSelection::Compliments_NiceShot,
            QuickChatSelection::Compliments_GreatPass,
            QuickChatSelection::Compliments_Thanks,
            QuickChatSelection::Compliments_WhatASave,
            QuickChatSelection::Compliments_NiceOne,
            QuickChatSelection::Compliments_WhatAPlay,
            QuickChatSelection::Compliments_GreatClear,
            QuickChatSelection::Compliments_NiceBlock,
            QuickChatSelection::Reactions_OMG,
            QuickChatSelection::Reactions_Noooo,
            QuickChatSelection::Reactions_Wow,
            QuickChatSelection::Reactions_CloseOne,
            QuickChatSelection::Reactions_NoWay,
            QuickChatSelection::Reactions_HolyCow,
            QuickChatSelection::Reactions_Whew,
            QuickChatSelection::Reactions_Siiiick,
            QuickChatSelection::Reactions_Calculated,
            QuickChatSelection::Reactions_Savage,
            QuickChatSelection::Reactions_Okay,
            QuickChatSelection::Apologies_Cursing,
            QuickChatSelection::Apologies_NoProblem,
            QuickChatSelection::Apologies_Whoops,
            QuickChatSelection::Apologies_Sorry,
            QuickChatSelection::Apologies_MyBad,
            QuickChatSelection::Apologies_Oops,
            QuickChatSelection::Apologies_MyFault,
            QuickChatSelection::PostGame_Gg,
            QuickChatSelection::PostGame_WellPlayed,
            QuickChatSelection::PostGame_ThatWasFun,
            QuickChatSelection::PostGame_Rematch,
            QuickChatSelection::PostGame_OneMoreGame,
            QuickChatSelection::PostGame_WhatAGame,
            QuickChatSelection::PostGame_NiceMoves,
            QuickChatSelection::PostGame_EverybodyDance,
            QuickChatSelection::MaxPysonixQuickChatPresets,
            QuickChatSelection::Custom_Toxic_WasteCPU,
            QuickChatSelection::Custom_Toxic_GitGut,
            QuickChatSelection::Custom_Toxic_DeAlloc,
            QuickChatSelection::Custom_Toxic_404NoSkill,
            QuickChatSelection::Custom_Toxic_CatchVirus,
            QuickChatSelection::Custom_Useful_Passing,
            QuickChatSelection::Custom_Useful_Faking,
            QuickChatSelection::Custom_Useful_Demoing,
            QuickChatSelection::Custom_Useful_Bumping,
            QuickChatSelection::Custom_Compliments_TinyChances,
            QuickChatSelection::Custom_Compliments_SkillLevel,
            QuickChatSelection::Custom_Compliments_proud,
            QuickChatSelection::Custom_Compliments_GC,
            QuickChatSelection::Custom_Compliments_Pro,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_QUICK_CHAT_SELECTION: [&'static str; 58] = [
            "Information_IGotIt",
            "Information_NeedBoost",
            "Information_TakeTheShot",
            "Information_Defending",
            "Information_GoForIt",
            "Information_Centering",
            "Information_AllYours",
            "Information_InPosition",
            "Information_Incoming",
            "Compliments_NiceShot",
            "Compliments_GreatPass",
            "Compliments_Thanks",
            "Compliments_WhatASave",
            "Compliments_NiceOne",
            "Compliments_WhatAPlay",
            "Compliments_GreatClear",
            "Compliments_NiceBlock",
            "Reactions_OMG",
            "Reactions_Noooo",
            "Reactions_Wow",
            "Reactions_CloseOne",
            "Reactions_NoWay",
            "Reactions_HolyCow",
            "Reactions_Whew",
            "Reactions_Siiiick",
            "Reactions_Calculated",
            "Reactions_Savage",
            "Reactions_Okay",
            "Apologies_Cursing",
            "Apologies_NoProblem",
            "Apologies_Whoops",
            "Apologies_Sorry",
            "Apologies_MyBad",
            "Apologies_Oops",
            "Apologies_MyFault",
            "PostGame_Gg",
            "PostGame_WellPlayed",
            "PostGame_ThatWasFun",
            "PostGame_Rematch",
            "PostGame_OneMoreGame",
            "PostGame_WhatAGame",
            "PostGame_NiceMoves",
            "PostGame_EverybodyDance",
            "MaxPysonixQuickChatPresets",
            "Custom_Toxic_WasteCPU",
            "Custom_Toxic_GitGut",
            "Custom_Toxic_DeAlloc",
            "Custom_Toxic_404NoSkill",
            "Custom_Toxic_CatchVirus",
            "Custom_Useful_Passing",
            "Custom_Useful_Faking",
            "Custom_Useful_Demoing",
            "Custom_Useful_Bumping",
            "Custom_Compliments_TinyChances",
            "Custom_Compliments_SkillLevel",
            "Custom_Compliments_proud",
            "Custom_Compliments_GC",
            "Custom_Compliments_Pro",
        ];

        pub fn enum_name_quick_chat_selection(e: QuickChatSelection) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_QUICK_CHAT_SELECTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(u8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum PlayerClass {
            NONE = 0,
            RLBotPlayer = 1,
            HumanPlayer = 2,
            PsyonixBotPlayer = 3,
            PartyMemberBotPlayer = 4,
        }

        const ENUM_MIN_PLAYER_CLASS: u8 = 0;
        const ENUM_MAX_PLAYER_CLASS: u8 = 4;

        impl<'a> flatbuffers::Follow<'a> for PlayerClass {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for PlayerClass {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = u8::to_le(self as u8);
                let p = &n as *const u8 as *const PlayerClass;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = u8::from_le(self as u8);
                let p = &n as *const u8 as *const PlayerClass;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for PlayerClass {
            type Output = PlayerClass;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<PlayerClass>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_PLAYER_CLASS: [PlayerClass; 5] = [
            PlayerClass::NONE,
            PlayerClass::RLBotPlayer,
            PlayerClass::HumanPlayer,
            PlayerClass::PsyonixBotPlayer,
            PlayerClass::PartyMemberBotPlayer,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_PLAYER_CLASS: [&'static str; 5] = [
            "NONE",
            "RLBotPlayer",
            "HumanPlayer",
            "PsyonixBotPlayer",
            "PartyMemberBotPlayer",
        ];

        pub fn enum_name_player_class(e: PlayerClass) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_PLAYER_CLASS[index]
        }

        pub struct PlayerClassUnionTableOffset {}
        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum GameMode {
            Soccer = 0,
            Hoops = 1,
            Dropshot = 2,
            Hockey = 3,
            Rumble = 4,
        }

        const ENUM_MIN_GAME_MODE: i8 = 0;
        const ENUM_MAX_GAME_MODE: i8 = 4;

        impl<'a> flatbuffers::Follow<'a> for GameMode {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for GameMode {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const GameMode;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const GameMode;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for GameMode {
            type Output = GameMode;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<GameMode>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_GAME_MODE: [GameMode; 5] = [
            GameMode::Soccer,
            GameMode::Hoops,
            GameMode::Dropshot,
            GameMode::Hockey,
            GameMode::Rumble,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_GAME_MODE: [&'static str; 5] =
            ["Soccer", "Hoops", "Dropshot", "Hockey", "Rumble"];

        pub fn enum_name_game_mode(e: GameMode) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_GAME_MODE[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum GameMap {
            DFHStadium = 0,
            Mannfield = 1,
            ChampionsField = 2,
            UrbanCentral = 3,
            BeckwithPark = 4,
            UtopiaColiseum = 5,
            Wasteland = 6,
            NeoTokyo = 7,
            AquaDome = 8,
            StarbaseArc = 9,
            Farmstead = 10,
            SaltyShores = 11,
            DFHStadium_Stormy = 12,
            DFHStadium_Day = 13,
            Mannfield_Stormy = 14,
            Mannfield_Night = 15,
            ChampionsField_Day = 16,
            BeckwithPark_Stormy = 17,
            BeckwithPark_Midnight = 18,
            UrbanCentral_Night = 19,
            UrbanCentral_Dawn = 20,
            UtopiaColiseum_Dusk = 21,
            DFHStadium_Snowy = 22,
            Mannfield_Snowy = 23,
            UtopiaColiseum_Snowy = 24,
            Badlands = 25,
            Badlands_Night = 26,
            TokyoUnderpass = 27,
            Arctagon = 28,
            Pillars = 29,
            Cosmic = 30,
            DoubleGoal = 31,
            Octagon = 32,
            Underpass = 33,
            UtopiaRetro = 34,
            Hoops_DunkHouse = 35,
            DropShot_Core707 = 36,
            ThrowbackStadium = 37,
        }

        const ENUM_MIN_GAME_MAP: i8 = 0;
        const ENUM_MAX_GAME_MAP: i8 = 37;

        impl<'a> flatbuffers::Follow<'a> for GameMap {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for GameMap {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const GameMap;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const GameMap;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for GameMap {
            type Output = GameMap;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<GameMap>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_GAME_MAP: [GameMap; 38] = [
            GameMap::DFHStadium,
            GameMap::Mannfield,
            GameMap::ChampionsField,
            GameMap::UrbanCentral,
            GameMap::BeckwithPark,
            GameMap::UtopiaColiseum,
            GameMap::Wasteland,
            GameMap::NeoTokyo,
            GameMap::AquaDome,
            GameMap::StarbaseArc,
            GameMap::Farmstead,
            GameMap::SaltyShores,
            GameMap::DFHStadium_Stormy,
            GameMap::DFHStadium_Day,
            GameMap::Mannfield_Stormy,
            GameMap::Mannfield_Night,
            GameMap::ChampionsField_Day,
            GameMap::BeckwithPark_Stormy,
            GameMap::BeckwithPark_Midnight,
            GameMap::UrbanCentral_Night,
            GameMap::UrbanCentral_Dawn,
            GameMap::UtopiaColiseum_Dusk,
            GameMap::DFHStadium_Snowy,
            GameMap::Mannfield_Snowy,
            GameMap::UtopiaColiseum_Snowy,
            GameMap::Badlands,
            GameMap::Badlands_Night,
            GameMap::TokyoUnderpass,
            GameMap::Arctagon,
            GameMap::Pillars,
            GameMap::Cosmic,
            GameMap::DoubleGoal,
            GameMap::Octagon,
            GameMap::Underpass,
            GameMap::UtopiaRetro,
            GameMap::Hoops_DunkHouse,
            GameMap::DropShot_Core707,
            GameMap::ThrowbackStadium,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_GAME_MAP: [&'static str; 38] = [
            "DFHStadium",
            "Mannfield",
            "ChampionsField",
            "UrbanCentral",
            "BeckwithPark",
            "UtopiaColiseum",
            "Wasteland",
            "NeoTokyo",
            "AquaDome",
            "StarbaseArc",
            "Farmstead",
            "SaltyShores",
            "DFHStadium_Stormy",
            "DFHStadium_Day",
            "Mannfield_Stormy",
            "Mannfield_Night",
            "ChampionsField_Day",
            "BeckwithPark_Stormy",
            "BeckwithPark_Midnight",
            "UrbanCentral_Night",
            "UrbanCentral_Dawn",
            "UtopiaColiseum_Dusk",
            "DFHStadium_Snowy",
            "Mannfield_Snowy",
            "UtopiaColiseum_Snowy",
            "Badlands",
            "Badlands_Night",
            "TokyoUnderpass",
            "Arctagon",
            "Pillars",
            "Cosmic",
            "DoubleGoal",
            "Octagon",
            "Underpass",
            "UtopiaRetro",
            "Hoops_DunkHouse",
            "DropShot_Core707",
            "ThrowbackStadium",
        ];

        pub fn enum_name_game_map(e: GameMap) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_GAME_MAP[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum MatchLength {
            Five_Minutes = 0,
            Ten_Minutes = 1,
            Twenty_Minutes = 2,
            Unlimited = 3,
        }

        const ENUM_MIN_MATCH_LENGTH: i8 = 0;
        const ENUM_MAX_MATCH_LENGTH: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for MatchLength {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for MatchLength {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const MatchLength;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const MatchLength;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for MatchLength {
            type Output = MatchLength;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<MatchLength>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_MATCH_LENGTH: [MatchLength; 4] = [
            MatchLength::Five_Minutes,
            MatchLength::Ten_Minutes,
            MatchLength::Twenty_Minutes,
            MatchLength::Unlimited,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_MATCH_LENGTH: [&'static str; 4] =
            ["Five_Minutes", "Ten_Minutes", "Twenty_Minutes", "Unlimited"];

        pub fn enum_name_match_length(e: MatchLength) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_MATCH_LENGTH[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum MaxScore {
            Unlimited = 0,
            One_Goal = 1,
            Three_Goals = 2,
            Five_Goals = 3,
        }

        const ENUM_MIN_MAX_SCORE: i8 = 0;
        const ENUM_MAX_MAX_SCORE: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for MaxScore {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for MaxScore {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const MaxScore;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const MaxScore;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for MaxScore {
            type Output = MaxScore;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<MaxScore>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_MAX_SCORE: [MaxScore; 4] = [
            MaxScore::Unlimited,
            MaxScore::One_Goal,
            MaxScore::Three_Goals,
            MaxScore::Five_Goals,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_MAX_SCORE: [&'static str; 4] =
            ["Unlimited", "One_Goal", "Three_Goals", "Five_Goals"];

        pub fn enum_name_max_score(e: MaxScore) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_MAX_SCORE[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum OvertimeOption {
            Unlimited = 0,
            Five_Max_First_Score = 1,
            Five_Max_Random_Team = 2,
        }

        const ENUM_MIN_OVERTIME_OPTION: i8 = 0;
        const ENUM_MAX_OVERTIME_OPTION: i8 = 2;

        impl<'a> flatbuffers::Follow<'a> for OvertimeOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for OvertimeOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const OvertimeOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const OvertimeOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for OvertimeOption {
            type Output = OvertimeOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<OvertimeOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_OVERTIME_OPTION: [OvertimeOption; 3] = [
            OvertimeOption::Unlimited,
            OvertimeOption::Five_Max_First_Score,
            OvertimeOption::Five_Max_Random_Team,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_OVERTIME_OPTION: [&'static str; 3] =
            ["Unlimited", "Five_Max_First_Score", "Five_Max_Random_Team"];

        pub fn enum_name_overtime_option(e: OvertimeOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_OVERTIME_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum SeriesLengthOption {
            Unlimited = 0,
            Three_Games = 1,
            Five_Games = 2,
            Seven_Games = 3,
        }

        const ENUM_MIN_SERIES_LENGTH_OPTION: i8 = 0;
        const ENUM_MAX_SERIES_LENGTH_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for SeriesLengthOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for SeriesLengthOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const SeriesLengthOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const SeriesLengthOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for SeriesLengthOption {
            type Output = SeriesLengthOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<SeriesLengthOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_SERIES_LENGTH_OPTION: [SeriesLengthOption; 4] = [
            SeriesLengthOption::Unlimited,
            SeriesLengthOption::Three_Games,
            SeriesLengthOption::Five_Games,
            SeriesLengthOption::Seven_Games,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_SERIES_LENGTH_OPTION: [&'static str; 4] =
            ["Unlimited", "Three_Games", "Five_Games", "Seven_Games"];

        pub fn enum_name_series_length_option(e: SeriesLengthOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_SERIES_LENGTH_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum GameSpeedOption {
            Default = 0,
            Slo_Mo = 1,
            Time_Warp = 2,
        }

        const ENUM_MIN_GAME_SPEED_OPTION: i8 = 0;
        const ENUM_MAX_GAME_SPEED_OPTION: i8 = 2;

        impl<'a> flatbuffers::Follow<'a> for GameSpeedOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for GameSpeedOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const GameSpeedOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const GameSpeedOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for GameSpeedOption {
            type Output = GameSpeedOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<GameSpeedOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_GAME_SPEED_OPTION: [GameSpeedOption; 3] = [
            GameSpeedOption::Default,
            GameSpeedOption::Slo_Mo,
            GameSpeedOption::Time_Warp,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_GAME_SPEED_OPTION: [&'static str; 3] = ["Default", "Slo_Mo", "Time_Warp"];

        pub fn enum_name_game_speed_option(e: GameSpeedOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_GAME_SPEED_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum BallMaxSpeedOption {
            Default = 0,
            Slow = 1,
            Fast = 2,
            Super_Fast = 3,
        }

        const ENUM_MIN_BALL_MAX_SPEED_OPTION: i8 = 0;
        const ENUM_MAX_BALL_MAX_SPEED_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for BallMaxSpeedOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for BallMaxSpeedOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const BallMaxSpeedOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const BallMaxSpeedOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for BallMaxSpeedOption {
            type Output = BallMaxSpeedOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<BallMaxSpeedOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_BALL_MAX_SPEED_OPTION: [BallMaxSpeedOption; 4] = [
            BallMaxSpeedOption::Default,
            BallMaxSpeedOption::Slow,
            BallMaxSpeedOption::Fast,
            BallMaxSpeedOption::Super_Fast,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_BALL_MAX_SPEED_OPTION: [&'static str; 4] =
            ["Default", "Slow", "Fast", "Super_Fast"];

        pub fn enum_name_ball_max_speed_option(e: BallMaxSpeedOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_BALL_MAX_SPEED_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum BallTypeOption {
            Default = 0,
            Cube = 1,
            Puck = 2,
            Basketball = 3,
        }

        const ENUM_MIN_BALL_TYPE_OPTION: i8 = 0;
        const ENUM_MAX_BALL_TYPE_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for BallTypeOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for BallTypeOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const BallTypeOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const BallTypeOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for BallTypeOption {
            type Output = BallTypeOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<BallTypeOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_BALL_TYPE_OPTION: [BallTypeOption; 4] = [
            BallTypeOption::Default,
            BallTypeOption::Cube,
            BallTypeOption::Puck,
            BallTypeOption::Basketball,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_BALL_TYPE_OPTION: [&'static str; 4] =
            ["Default", "Cube", "Puck", "Basketball"];

        pub fn enum_name_ball_type_option(e: BallTypeOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_BALL_TYPE_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum BallWeightOption {
            Default = 0,
            Light = 1,
            Heavy = 2,
            Super_Light = 3,
        }

        const ENUM_MIN_BALL_WEIGHT_OPTION: i8 = 0;
        const ENUM_MAX_BALL_WEIGHT_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for BallWeightOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for BallWeightOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const BallWeightOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const BallWeightOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for BallWeightOption {
            type Output = BallWeightOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<BallWeightOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_BALL_WEIGHT_OPTION: [BallWeightOption; 4] = [
            BallWeightOption::Default,
            BallWeightOption::Light,
            BallWeightOption::Heavy,
            BallWeightOption::Super_Light,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_BALL_WEIGHT_OPTION: [&'static str; 4] =
            ["Default", "Light", "Heavy", "Super_Light"];

        pub fn enum_name_ball_weight_option(e: BallWeightOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_BALL_WEIGHT_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum BallSizeOption {
            Default = 0,
            Small = 1,
            Large = 2,
            Gigantic = 3,
        }

        const ENUM_MIN_BALL_SIZE_OPTION: i8 = 0;
        const ENUM_MAX_BALL_SIZE_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for BallSizeOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for BallSizeOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const BallSizeOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const BallSizeOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for BallSizeOption {
            type Output = BallSizeOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<BallSizeOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_BALL_SIZE_OPTION: [BallSizeOption; 4] = [
            BallSizeOption::Default,
            BallSizeOption::Small,
            BallSizeOption::Large,
            BallSizeOption::Gigantic,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_BALL_SIZE_OPTION: [&'static str; 4] =
            ["Default", "Small", "Large", "Gigantic"];

        pub fn enum_name_ball_size_option(e: BallSizeOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_BALL_SIZE_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum BallBouncinessOption {
            Default = 0,
            Low = 1,
            High = 2,
            Super_High = 3,
        }

        const ENUM_MIN_BALL_BOUNCINESS_OPTION: i8 = 0;
        const ENUM_MAX_BALL_BOUNCINESS_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for BallBouncinessOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for BallBouncinessOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const BallBouncinessOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const BallBouncinessOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for BallBouncinessOption {
            type Output = BallBouncinessOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<BallBouncinessOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_BALL_BOUNCINESS_OPTION: [BallBouncinessOption; 4] = [
            BallBouncinessOption::Default,
            BallBouncinessOption::Low,
            BallBouncinessOption::High,
            BallBouncinessOption::Super_High,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_BALL_BOUNCINESS_OPTION: [&'static str; 4] =
            ["Default", "Low", "High", "Super_High"];

        pub fn enum_name_ball_bounciness_option(e: BallBouncinessOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_BALL_BOUNCINESS_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum BoostOption {
            Normal_Boost = 0,
            Unlimited_Boost = 1,
            Slow_Recharge = 2,
            Rapid_Recharge = 3,
            No_Boost = 4,
        }

        const ENUM_MIN_BOOST_OPTION: i8 = 0;
        const ENUM_MAX_BOOST_OPTION: i8 = 4;

        impl<'a> flatbuffers::Follow<'a> for BoostOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for BoostOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const BoostOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const BoostOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for BoostOption {
            type Output = BoostOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<BoostOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_BOOST_OPTION: [BoostOption; 5] = [
            BoostOption::Normal_Boost,
            BoostOption::Unlimited_Boost,
            BoostOption::Slow_Recharge,
            BoostOption::Rapid_Recharge,
            BoostOption::No_Boost,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_BOOST_OPTION: [&'static str; 5] = [
            "Normal_Boost",
            "Unlimited_Boost",
            "Slow_Recharge",
            "Rapid_Recharge",
            "No_Boost",
        ];

        pub fn enum_name_boost_option(e: BoostOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_BOOST_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum RumbleOption {
            No_Rumble = 0,
            Default = 1,
            Slow = 2,
            Civilized = 3,
            Destruction_Derby = 4,
            Spring_Loaded = 5,
            Spikes_Only = 6,
            Spike_Rush = 7,
        }

        const ENUM_MIN_RUMBLE_OPTION: i8 = 0;
        const ENUM_MAX_RUMBLE_OPTION: i8 = 7;

        impl<'a> flatbuffers::Follow<'a> for RumbleOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for RumbleOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const RumbleOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const RumbleOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for RumbleOption {
            type Output = RumbleOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<RumbleOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_RUMBLE_OPTION: [RumbleOption; 8] = [
            RumbleOption::No_Rumble,
            RumbleOption::Default,
            RumbleOption::Slow,
            RumbleOption::Civilized,
            RumbleOption::Destruction_Derby,
            RumbleOption::Spring_Loaded,
            RumbleOption::Spikes_Only,
            RumbleOption::Spike_Rush,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_RUMBLE_OPTION: [&'static str; 8] = [
            "No_Rumble",
            "Default",
            "Slow",
            "Civilized",
            "Destruction_Derby",
            "Spring_Loaded",
            "Spikes_Only",
            "Spike_Rush",
        ];

        pub fn enum_name_rumble_option(e: RumbleOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_RUMBLE_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum BoostStrengthOption {
            One = 0,
            OneAndAHalf = 1,
            Two = 2,
            Ten = 3,
        }

        const ENUM_MIN_BOOST_STRENGTH_OPTION: i8 = 0;
        const ENUM_MAX_BOOST_STRENGTH_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for BoostStrengthOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for BoostStrengthOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const BoostStrengthOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const BoostStrengthOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for BoostStrengthOption {
            type Output = BoostStrengthOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<BoostStrengthOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_BOOST_STRENGTH_OPTION: [BoostStrengthOption; 4] = [
            BoostStrengthOption::One,
            BoostStrengthOption::OneAndAHalf,
            BoostStrengthOption::Two,
            BoostStrengthOption::Ten,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_BOOST_STRENGTH_OPTION: [&'static str; 4] =
            ["One", "OneAndAHalf", "Two", "Ten"];

        pub fn enum_name_boost_strength_option(e: BoostStrengthOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_BOOST_STRENGTH_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum GravityOption {
            Default = 0,
            Low = 1,
            High = 2,
            Super_High = 3,
        }

        const ENUM_MIN_GRAVITY_OPTION: i8 = 0;
        const ENUM_MAX_GRAVITY_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for GravityOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for GravityOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const GravityOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const GravityOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for GravityOption {
            type Output = GravityOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<GravityOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_GRAVITY_OPTION: [GravityOption; 4] = [
            GravityOption::Default,
            GravityOption::Low,
            GravityOption::High,
            GravityOption::Super_High,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_GRAVITY_OPTION: [&'static str; 4] =
            ["Default", "Low", "High", "Super_High"];

        pub fn enum_name_gravity_option(e: GravityOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_GRAVITY_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum DemolishOption {
            Default = 0,
            Disabled = 1,
            Friendly_Fire = 2,
            On_Contact = 3,
            On_Contact_FF = 4,
        }

        const ENUM_MIN_DEMOLISH_OPTION: i8 = 0;
        const ENUM_MAX_DEMOLISH_OPTION: i8 = 4;

        impl<'a> flatbuffers::Follow<'a> for DemolishOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for DemolishOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const DemolishOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const DemolishOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for DemolishOption {
            type Output = DemolishOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<DemolishOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_DEMOLISH_OPTION: [DemolishOption; 5] = [
            DemolishOption::Default,
            DemolishOption::Disabled,
            DemolishOption::Friendly_Fire,
            DemolishOption::On_Contact,
            DemolishOption::On_Contact_FF,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_DEMOLISH_OPTION: [&'static str; 5] = [
            "Default",
            "Disabled",
            "Friendly_Fire",
            "On_Contact",
            "On_Contact_FF",
        ];

        pub fn enum_name_demolish_option(e: DemolishOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_DEMOLISH_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum RespawnTimeOption {
            Three_Seconds = 0,
            Two_Seconds = 1,
            One_Seconds = 2,
            Disable_Goal_Reset = 3,
        }

        const ENUM_MIN_RESPAWN_TIME_OPTION: i8 = 0;
        const ENUM_MAX_RESPAWN_TIME_OPTION: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for RespawnTimeOption {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for RespawnTimeOption {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const RespawnTimeOption;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const RespawnTimeOption;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for RespawnTimeOption {
            type Output = RespawnTimeOption;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<RespawnTimeOption>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_RESPAWN_TIME_OPTION: [RespawnTimeOption; 4] = [
            RespawnTimeOption::Three_Seconds,
            RespawnTimeOption::Two_Seconds,
            RespawnTimeOption::One_Seconds,
            RespawnTimeOption::Disable_Goal_Reset,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_RESPAWN_TIME_OPTION: [&'static str; 4] = [
            "Three_Seconds",
            "Two_Seconds",
            "One_Seconds",
            "Disable_Goal_Reset",
        ];

        pub fn enum_name_respawn_time_option(e: RespawnTimeOption) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_RESPAWN_TIME_OPTION[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum ExistingMatchBehavior {
            /// Restart the match if any match settings differ. This is the
            /// default because old RLBot always worked this way.
            Restart_If_Different = 0,
            /// Always restart the match, even if config is identical
            Restart = 1,
            /// Never restart an existing match, just try to remove or spawn
            /// cars to match the configuration. If we are not in
            /// the middle of a match, a match will be started. Handy for LAN
            /// matches.
            Continue_And_Spawn = 2,
        }

        const ENUM_MIN_EXISTING_MATCH_BEHAVIOR: i8 = 0;
        const ENUM_MAX_EXISTING_MATCH_BEHAVIOR: i8 = 2;

        impl<'a> flatbuffers::Follow<'a> for ExistingMatchBehavior {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for ExistingMatchBehavior {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const ExistingMatchBehavior;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const ExistingMatchBehavior;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for ExistingMatchBehavior {
            type Output = ExistingMatchBehavior;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<ExistingMatchBehavior>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_EXISTING_MATCH_BEHAVIOR: [ExistingMatchBehavior; 3] = [
            ExistingMatchBehavior::Restart_If_Different,
            ExistingMatchBehavior::Restart,
            ExistingMatchBehavior::Continue_And_Spawn,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_EXISTING_MATCH_BEHAVIOR: [&'static str; 3] =
            ["Restart_If_Different", "Restart", "Continue_And_Spawn"];

        pub fn enum_name_existing_match_behavior(e: ExistingMatchBehavior) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_EXISTING_MATCH_BEHAVIOR[index]
        }

        // struct Vector3, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Vector3 {
            x_: f32,
            y_: f32,
            z_: f32,
        } // pub struct Vector3
        impl flatbuffers::SafeSliceAccess for Vector3 {}
        impl<'a> flatbuffers::Follow<'a> for Vector3 {
            type Inner = &'a Vector3;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Vector3>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Vector3 {
            type Inner = &'a Vector3;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Vector3>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Vector3 {
            type Output = Vector3;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Vector3 as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Vector3 {
            type Output = Vector3;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Vector3 as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Vector3 {
            pub fn new<'a>(_x: f32, _y: f32, _z: f32) -> Self {
                Vector3 {
                    x_: _x.to_little_endian(),
                    y_: _y.to_little_endian(),
                    z_: _z.to_little_endian(),
                }
            }
            pub fn x<'a>(&'a self) -> f32 {
                self.x_.from_little_endian()
            }
            pub fn y<'a>(&'a self) -> f32 {
                self.y_.from_little_endian()
            }
            pub fn z<'a>(&'a self) -> f32 {
                self.z_.from_little_endian()
            }
        }

        /// Expresses the rotation state of an object in Euler angles, with
        /// values in radians.
        // struct Rotator, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Rotator {
            pitch_: f32,
            yaw_: f32,
            roll_: f32,
        } // pub struct Rotator
        impl flatbuffers::SafeSliceAccess for Rotator {}
        impl<'a> flatbuffers::Follow<'a> for Rotator {
            type Inner = &'a Rotator;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Rotator>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Rotator {
            type Inner = &'a Rotator;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Rotator>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Rotator {
            type Output = Rotator;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Rotator as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Rotator {
            type Output = Rotator;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Rotator as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Rotator {
            pub fn new<'a>(_pitch: f32, _yaw: f32, _roll: f32) -> Self {
                Rotator {
                    pitch_: _pitch.to_little_endian(),
                    yaw_: _yaw.to_little_endian(),
                    roll_: _roll.to_little_endian(),
                }
            }
            pub fn pitch<'a>(&'a self) -> f32 {
                self.pitch_.from_little_endian()
            }
            pub fn yaw<'a>(&'a self) -> f32 {
                self.yaw_.from_little_endian()
            }
            pub fn roll<'a>(&'a self) -> f32 {
                self.roll_.from_little_endian()
            }
        }

        /// Expresses the rotation state of an object.
        /// Learn about quaternions here: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
        /// You can tinker with them here to build an intuition: https://quaternions.online/
        // struct Quaternion, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Quaternion {
            x_: f32,
            y_: f32,
            z_: f32,
            w_: f32,
        } // pub struct Quaternion
        impl flatbuffers::SafeSliceAccess for Quaternion {}
        impl<'a> flatbuffers::Follow<'a> for Quaternion {
            type Inner = &'a Quaternion;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Quaternion>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Quaternion {
            type Inner = &'a Quaternion;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Quaternion>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Quaternion {
            type Output = Quaternion;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(
                        self as *const Quaternion as *const u8,
                        Self::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Quaternion {
            type Output = Quaternion;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(
                        *self as *const Quaternion as *const u8,
                        Self::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
        }

        impl Quaternion {
            pub fn new<'a>(_x: f32, _y: f32, _z: f32, _w: f32) -> Self {
                Quaternion {
                    x_: _x.to_little_endian(),
                    y_: _y.to_little_endian(),
                    z_: _z.to_little_endian(),
                    w_: _w.to_little_endian(),
                }
            }
            pub fn x<'a>(&'a self) -> f32 {
                self.x_.from_little_endian()
            }
            pub fn y<'a>(&'a self) -> f32 {
                self.y_.from_little_endian()
            }
            pub fn z<'a>(&'a self) -> f32 {
                self.z_.from_little_endian()
            }
            pub fn w<'a>(&'a self) -> f32 {
                self.w_.from_little_endian()
            }
        }

        // struct Float, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Float {
            val_: f32,
        } // pub struct Float
        impl flatbuffers::SafeSliceAccess for Float {}
        impl<'a> flatbuffers::Follow<'a> for Float {
            type Inner = &'a Float;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Float>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Float {
            type Inner = &'a Float;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Float>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Float {
            type Output = Float;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Float as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Float {
            type Output = Float;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Float as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Float {
            pub fn new<'a>(_val: f32) -> Self {
                Float {
                    val_: _val.to_little_endian(),
                }
            }
            pub fn val<'a>(&'a self) -> f32 {
                self.val_.from_little_endian()
            }
        }

        // struct Bool, aligned to 1
        #[repr(C, align(1))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Bool {
            val_: bool,
        } // pub struct Bool
        impl flatbuffers::SafeSliceAccess for Bool {}
        impl<'a> flatbuffers::Follow<'a> for Bool {
            type Inner = &'a Bool;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Bool>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Bool {
            type Inner = &'a Bool;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Bool>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Bool {
            type Output = Bool;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Bool as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Bool {
            type Output = Bool;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Bool as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Bool {
            pub fn new<'a>(_val: bool) -> Self {
                Bool {
                    val_: _val.to_little_endian(),
                }
            }
            pub fn val<'a>(&'a self) -> bool {
                self.val_.from_little_endian()
            }
        }

        pub enum ControllerStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct ControllerState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ControllerState<'a> {
            type Inner = ControllerState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> ControllerState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ControllerState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ControllerStateArgs,
            ) -> flatbuffers::WIPOffset<ControllerState<'bldr>> {
                let mut builder = ControllerStateBuilder::new(_fbb);
                builder.add_roll(args.roll);
                builder.add_yaw(args.yaw);
                builder.add_pitch(args.pitch);
                builder.add_steer(args.steer);
                builder.add_throttle(args.throttle);
                builder.add_useItem(args.useItem);
                builder.add_handbrake(args.handbrake);
                builder.add_boost(args.boost);
                builder.add_jump(args.jump);
                builder.finish()
            }

            pub const VT_THROTTLE: flatbuffers::VOffsetT = 4;
            pub const VT_STEER: flatbuffers::VOffsetT = 6;
            pub const VT_PITCH: flatbuffers::VOffsetT = 8;
            pub const VT_YAW: flatbuffers::VOffsetT = 10;
            pub const VT_ROLL: flatbuffers::VOffsetT = 12;
            pub const VT_JUMP: flatbuffers::VOffsetT = 14;
            pub const VT_BOOST: flatbuffers::VOffsetT = 16;
            pub const VT_HANDBRAKE: flatbuffers::VOffsetT = 18;
            pub const VT_USEITEM: flatbuffers::VOffsetT = 20;

            /// -1 for full reverse, 1 for full forward
            #[inline]
            pub fn throttle(&self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_THROTTLE, Some(0.0))
                    .unwrap()
            }
            /// -1 for full left, 1 for full right
            #[inline]
            pub fn steer(&self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_STEER, Some(0.0))
                    .unwrap()
            }
            /// -1 for nose down, 1 for nose up
            #[inline]
            pub fn pitch(&self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_PITCH, Some(0.0))
                    .unwrap()
            }
            /// -1 for full left, 1 for full right
            #[inline]
            pub fn yaw(&self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_YAW, Some(0.0))
                    .unwrap()
            }
            /// -1 for roll left, 1 for roll right
            #[inline]
            pub fn roll(&self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_ROLL, Some(0.0))
                    .unwrap()
            }
            /// true if you want to press the jump button
            #[inline]
            pub fn jump(&self) -> bool {
                self._tab
                    .get::<bool>(ControllerState::VT_JUMP, Some(false))
                    .unwrap()
            }
            /// true if you want to press the boost button
            #[inline]
            pub fn boost(&self) -> bool {
                self._tab
                    .get::<bool>(ControllerState::VT_BOOST, Some(false))
                    .unwrap()
            }
            /// true if you want to press the handbrake button
            #[inline]
            pub fn handbrake(&self) -> bool {
                self._tab
                    .get::<bool>(ControllerState::VT_HANDBRAKE, Some(false))
                    .unwrap()
            }
            /// true if you want to press the 'use item' button, used in rumble
            /// etc.
            #[inline]
            pub fn useItem(&self) -> bool {
                self._tab
                    .get::<bool>(ControllerState::VT_USEITEM, Some(false))
                    .unwrap()
            }
        }

        pub struct ControllerStateArgs {
            pub throttle: f32,
            pub steer: f32,
            pub pitch: f32,
            pub yaw: f32,
            pub roll: f32,
            pub jump: bool,
            pub boost: bool,
            pub handbrake: bool,
            pub useItem: bool,
        }
        impl<'a> Default for ControllerStateArgs {
            #[inline]
            fn default() -> Self {
                ControllerStateArgs {
                    throttle: 0.0,
                    steer: 0.0,
                    pitch: 0.0,
                    yaw: 0.0,
                    roll: 0.0,
                    jump: false,
                    boost: false,
                    handbrake: false,
                    useItem: false,
                }
            }
        }
        pub struct ControllerStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ControllerStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_throttle(&mut self, throttle: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_THROTTLE, throttle, 0.0);
            }
            #[inline]
            pub fn add_steer(&mut self, steer: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_STEER, steer, 0.0);
            }
            #[inline]
            pub fn add_pitch(&mut self, pitch: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_PITCH, pitch, 0.0);
            }
            #[inline]
            pub fn add_yaw(&mut self, yaw: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_YAW, yaw, 0.0);
            }
            #[inline]
            pub fn add_roll(&mut self, roll: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_ROLL, roll, 0.0);
            }
            #[inline]
            pub fn add_jump(&mut self, jump: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_JUMP, jump, false);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_BOOST, boost, false);
            }
            #[inline]
            pub fn add_handbrake(&mut self, handbrake: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_HANDBRAKE, handbrake, false);
            }
            #[inline]
            pub fn add_useItem(&mut self, useItem: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_USEITEM, useItem, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ControllerStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ControllerStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ControllerState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PlayerInputOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PlayerInput<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerInput<'a> {
            type Inner = PlayerInput<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PlayerInput<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerInput { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerInputArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerInput<'bldr>> {
                let mut builder = PlayerInputBuilder::new(_fbb);
                if let Some(x) = args.controllerState {
                    builder.add_controllerState(x);
                }
                builder.add_playerIndex(args.playerIndex);
                builder.finish()
            }

            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;
            pub const VT_CONTROLLERSTATE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn playerIndex(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerInput::VT_PLAYERINDEX, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn controllerState(&self) -> Option<ControllerState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ControllerState<'a>>>(
                        PlayerInput::VT_CONTROLLERSTATE,
                        None,
                    )
            }
        }

        pub struct PlayerInputArgs<'a> {
            pub playerIndex: i32,
            pub controllerState: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
        }
        impl<'a> Default for PlayerInputArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerInputArgs {
                    playerIndex: 0,
                    controllerState: None,
                }
            }
        }
        pub struct PlayerInputBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerInputBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerInput::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn add_controllerState(
                &mut self,
                controllerState: flatbuffers::WIPOffset<ControllerState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ControllerState<'_>>>(
                        PlayerInput::VT_CONTROLLERSTATE,
                        controllerState,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerInputBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerInputBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInput<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BoxShapeOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BoxShape<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BoxShape<'a> {
            type Inner = BoxShape<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BoxShape<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BoxShape { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoxShapeArgs,
            ) -> flatbuffers::WIPOffset<BoxShape<'bldr>> {
                let mut builder = BoxShapeBuilder::new(_fbb);
                builder.add_height(args.height);
                builder.add_width(args.width);
                builder.add_length(args.length);
                builder.finish()
            }

            pub const VT_LENGTH: flatbuffers::VOffsetT = 4;
            pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
            pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn length(&self) -> f32 {
                self._tab
                    .get::<f32>(BoxShape::VT_LENGTH, Some(0.0))
                    .unwrap()
            }
            #[inline]
            pub fn width(&self) -> f32 {
                self._tab.get::<f32>(BoxShape::VT_WIDTH, Some(0.0)).unwrap()
            }
            #[inline]
            pub fn height(&self) -> f32 {
                self._tab
                    .get::<f32>(BoxShape::VT_HEIGHT, Some(0.0))
                    .unwrap()
            }
        }

        pub struct BoxShapeArgs {
            pub length: f32,
            pub width: f32,
            pub height: f32,
        }
        impl<'a> Default for BoxShapeArgs {
            #[inline]
            fn default() -> Self {
                BoxShapeArgs {
                    length: 0.0,
                    width: 0.0,
                    height: 0.0,
                }
            }
        }
        pub struct BoxShapeBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoxShapeBuilder<'a, 'b> {
            #[inline]
            pub fn add_length(&mut self, length: f32) {
                self.fbb_.push_slot::<f32>(BoxShape::VT_LENGTH, length, 0.0);
            }
            #[inline]
            pub fn add_width(&mut self, width: f32) {
                self.fbb_.push_slot::<f32>(BoxShape::VT_WIDTH, width, 0.0);
            }
            #[inline]
            pub fn add_height(&mut self, height: f32) {
                self.fbb_.push_slot::<f32>(BoxShape::VT_HEIGHT, height, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BoxShapeBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoxShapeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BoxShape<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum SphereShapeOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct SphereShape<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SphereShape<'a> {
            type Inner = SphereShape<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> SphereShape<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SphereShape { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args SphereShapeArgs,
            ) -> flatbuffers::WIPOffset<SphereShape<'bldr>> {
                let mut builder = SphereShapeBuilder::new(_fbb);
                builder.add_diameter(args.diameter);
                builder.finish()
            }

            pub const VT_DIAMETER: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn diameter(&self) -> f32 {
                self._tab
                    .get::<f32>(SphereShape::VT_DIAMETER, Some(0.0))
                    .unwrap()
            }
        }

        pub struct SphereShapeArgs {
            pub diameter: f32,
        }
        impl<'a> Default for SphereShapeArgs {
            #[inline]
            fn default() -> Self {
                SphereShapeArgs { diameter: 0.0 }
            }
        }
        pub struct SphereShapeBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> SphereShapeBuilder<'a, 'b> {
            #[inline]
            pub fn add_diameter(&mut self, diameter: f32) {
                self.fbb_
                    .push_slot::<f32>(SphereShape::VT_DIAMETER, diameter, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> SphereShapeBuilder<'a, 'b> {
                let start = _fbb.start_table();
                SphereShapeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SphereShape<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum CylinderShapeOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct CylinderShape<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CylinderShape<'a> {
            type Inner = CylinderShape<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> CylinderShape<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CylinderShape { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args CylinderShapeArgs,
            ) -> flatbuffers::WIPOffset<CylinderShape<'bldr>> {
                let mut builder = CylinderShapeBuilder::new(_fbb);
                builder.add_height(args.height);
                builder.add_diameter(args.diameter);
                builder.finish()
            }

            pub const VT_DIAMETER: flatbuffers::VOffsetT = 4;
            pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn diameter(&self) -> f32 {
                self._tab
                    .get::<f32>(CylinderShape::VT_DIAMETER, Some(0.0))
                    .unwrap()
            }
            #[inline]
            pub fn height(&self) -> f32 {
                self._tab
                    .get::<f32>(CylinderShape::VT_HEIGHT, Some(0.0))
                    .unwrap()
            }
        }

        pub struct CylinderShapeArgs {
            pub diameter: f32,
            pub height: f32,
        }
        impl<'a> Default for CylinderShapeArgs {
            #[inline]
            fn default() -> Self {
                CylinderShapeArgs {
                    diameter: 0.0,
                    height: 0.0,
                }
            }
        }
        pub struct CylinderShapeBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> CylinderShapeBuilder<'a, 'b> {
            #[inline]
            pub fn add_diameter(&mut self, diameter: f32) {
                self.fbb_
                    .push_slot::<f32>(CylinderShape::VT_DIAMETER, diameter, 0.0);
            }
            #[inline]
            pub fn add_height(&mut self, height: f32) {
                self.fbb_
                    .push_slot::<f32>(CylinderShape::VT_HEIGHT, height, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> CylinderShapeBuilder<'a, 'b> {
                let start = _fbb.start_table();
                CylinderShapeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CylinderShape<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum TouchOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Touch<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Touch<'a> {
            type Inner = Touch<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> Touch<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Touch { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TouchArgs<'args>,
            ) -> flatbuffers::WIPOffset<Touch<'bldr>> {
                let mut builder = TouchBuilder::new(_fbb);
                builder.add_playerIndex(args.playerIndex);
                builder.add_team(args.team);
                if let Some(x) = args.normal {
                    builder.add_normal(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_gameSeconds(args.gameSeconds);
                if let Some(x) = args.playerName {
                    builder.add_playerName(x);
                }
                builder.finish()
            }

            pub const VT_PLAYERNAME: flatbuffers::VOffsetT = 4;
            pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 6;
            pub const VT_LOCATION: flatbuffers::VOffsetT = 8;
            pub const VT_NORMAL: flatbuffers::VOffsetT = 10;
            pub const VT_TEAM: flatbuffers::VOffsetT = 12;
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 14;

            /// The name of the player involved with the touch.
            #[inline]
            pub fn playerName(&self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Touch::VT_PLAYERNAME, None)
            }
            /// Seconds that had elapsed in the game when the touch occurred.
            #[inline]
            pub fn gameSeconds(&self) -> f32 {
                self._tab
                    .get::<f32>(Touch::VT_GAMESECONDS, Some(0.0))
                    .unwrap()
            }
            /// The point of contact for the touch.
            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Touch::VT_LOCATION, None)
            }
            /// The direction of the touch.
            #[inline]
            pub fn normal(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Touch::VT_NORMAL, None)
            }
            /// The Team which the touch belongs to, 0 for blue 1 for orange.
            #[inline]
            pub fn team(&self) -> i32 {
                self._tab.get::<i32>(Touch::VT_TEAM, Some(0)).unwrap()
            }
            /// The index of the player involved with the touch.
            #[inline]
            pub fn playerIndex(&self) -> i32 {
                self._tab
                    .get::<i32>(Touch::VT_PLAYERINDEX, Some(0))
                    .unwrap()
            }
        }

        pub struct TouchArgs<'a> {
            pub playerName: Option<flatbuffers::WIPOffset<&'a str>>,
            pub gameSeconds: f32,
            pub location: Option<&'a Vector3>,
            pub normal: Option<&'a Vector3>,
            pub team: i32,
            pub playerIndex: i32,
        }
        impl<'a> Default for TouchArgs<'a> {
            #[inline]
            fn default() -> Self {
                TouchArgs {
                    playerName: None,
                    gameSeconds: 0.0,
                    location: None,
                    normal: None,
                    team: 0,
                    playerIndex: 0,
                }
            }
        }
        pub struct TouchBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TouchBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerName(&mut self, playerName: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Touch::VT_PLAYERNAME,
                    playerName,
                );
            }
            #[inline]
            pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
                self.fbb_
                    .push_slot::<f32>(Touch::VT_GAMESECONDS, gameSeconds, 0.0);
            }
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Touch::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_normal(&mut self, normal: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Touch::VT_NORMAL, normal);
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_.push_slot::<i32>(Touch::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(Touch::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TouchBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TouchBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Touch<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum ScoreInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct ScoreInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ScoreInfo<'a> {
            type Inner = ScoreInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> ScoreInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ScoreInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ScoreInfoArgs,
            ) -> flatbuffers::WIPOffset<ScoreInfo<'bldr>> {
                let mut builder = ScoreInfoBuilder::new(_fbb);
                builder.add_demolitions(args.demolitions);
                builder.add_shots(args.shots);
                builder.add_saves(args.saves);
                builder.add_assists(args.assists);
                builder.add_ownGoals(args.ownGoals);
                builder.add_goals(args.goals);
                builder.add_score(args.score);
                builder.finish()
            }

            pub const VT_SCORE: flatbuffers::VOffsetT = 4;
            pub const VT_GOALS: flatbuffers::VOffsetT = 6;
            pub const VT_OWNGOALS: flatbuffers::VOffsetT = 8;
            pub const VT_ASSISTS: flatbuffers::VOffsetT = 10;
            pub const VT_SAVES: flatbuffers::VOffsetT = 12;
            pub const VT_SHOTS: flatbuffers::VOffsetT = 14;
            pub const VT_DEMOLITIONS: flatbuffers::VOffsetT = 16;

            #[inline]
            pub fn score(&self) -> i32 {
                self._tab.get::<i32>(ScoreInfo::VT_SCORE, Some(0)).unwrap()
            }
            #[inline]
            pub fn goals(&self) -> i32 {
                self._tab.get::<i32>(ScoreInfo::VT_GOALS, Some(0)).unwrap()
            }
            #[inline]
            pub fn ownGoals(&self) -> i32 {
                self._tab
                    .get::<i32>(ScoreInfo::VT_OWNGOALS, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn assists(&self) -> i32 {
                self._tab
                    .get::<i32>(ScoreInfo::VT_ASSISTS, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn saves(&self) -> i32 {
                self._tab.get::<i32>(ScoreInfo::VT_SAVES, Some(0)).unwrap()
            }
            #[inline]
            pub fn shots(&self) -> i32 {
                self._tab.get::<i32>(ScoreInfo::VT_SHOTS, Some(0)).unwrap()
            }
            #[inline]
            pub fn demolitions(&self) -> i32 {
                self._tab
                    .get::<i32>(ScoreInfo::VT_DEMOLITIONS, Some(0))
                    .unwrap()
            }
        }

        pub struct ScoreInfoArgs {
            pub score: i32,
            pub goals: i32,
            pub ownGoals: i32,
            pub assists: i32,
            pub saves: i32,
            pub shots: i32,
            pub demolitions: i32,
        }
        impl<'a> Default for ScoreInfoArgs {
            #[inline]
            fn default() -> Self {
                ScoreInfoArgs {
                    score: 0,
                    goals: 0,
                    ownGoals: 0,
                    assists: 0,
                    saves: 0,
                    shots: 0,
                    demolitions: 0,
                }
            }
        }
        pub struct ScoreInfoBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ScoreInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_score(&mut self, score: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SCORE, score, 0);
            }
            #[inline]
            pub fn add_goals(&mut self, goals: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_GOALS, goals, 0);
            }
            #[inline]
            pub fn add_ownGoals(&mut self, ownGoals: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_OWNGOALS, ownGoals, 0);
            }
            #[inline]
            pub fn add_assists(&mut self, assists: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_ASSISTS, assists, 0);
            }
            #[inline]
            pub fn add_saves(&mut self, saves: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SAVES, saves, 0);
            }
            #[inline]
            pub fn add_shots(&mut self, shots: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SHOTS, shots, 0);
            }
            #[inline]
            pub fn add_demolitions(&mut self, demolitions: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_DEMOLITIONS, demolitions, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ScoreInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ScoreInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ScoreInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PhysicsOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Physics<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Physics<'a> {
            type Inner = Physics<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> Physics<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Physics { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PhysicsArgs<'args>,
            ) -> flatbuffers::WIPOffset<Physics<'bldr>> {
                let mut builder = PhysicsBuilder::new(_fbb);
                if let Some(x) = args.angularVelocity {
                    builder.add_angularVelocity(x);
                }
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Physics::VT_LOCATION, None)
            }
            #[inline]
            pub fn rotation(&self) -> Option<&'a Rotator> {
                self._tab.get::<Rotator>(Physics::VT_ROTATION, None)
            }
            #[inline]
            pub fn velocity(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Physics::VT_VELOCITY, None)
            }
            #[inline]
            pub fn angularVelocity(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Physics::VT_ANGULARVELOCITY, None)
            }
        }

        pub struct PhysicsArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub rotation: Option<&'a Rotator>,
            pub velocity: Option<&'a Vector3>,
            pub angularVelocity: Option<&'a Vector3>,
        }
        impl<'a> Default for PhysicsArgs<'a> {
            #[inline]
            fn default() -> Self {
                PhysicsArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }
        pub struct PhysicsBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PhysicsBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: &'b Rotator) {
                self.fbb_
                    .push_slot_always::<&Rotator>(Physics::VT_ROTATION, rotation);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn add_angularVelocity(&mut self, angularVelocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_ANGULARVELOCITY, angularVelocity);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PhysicsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PhysicsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Physics<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PlayerInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PlayerInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerInfo<'a> {
            type Inner = PlayerInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PlayerInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerInfo<'bldr>> {
                let mut builder = PlayerInfoBuilder::new(_fbb);
                if let Some(x) = args.hitbox {
                    builder.add_hitbox(x);
                }
                builder.add_boost(args.boost);
                builder.add_team(args.team);
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                if let Some(x) = args.scoreInfo {
                    builder.add_scoreInfo(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.add_doubleJumped(args.doubleJumped);
                builder.add_jumped(args.jumped);
                builder.add_isBot(args.isBot);
                builder.add_isSupersonic(args.isSupersonic);
                builder.add_hasWheelContact(args.hasWheelContact);
                builder.add_isDemolished(args.isDemolished);
                builder.finish()
            }

            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_SCOREINFO: flatbuffers::VOffsetT = 6;
            pub const VT_ISDEMOLISHED: flatbuffers::VOffsetT = 8;
            pub const VT_HASWHEELCONTACT: flatbuffers::VOffsetT = 10;
            pub const VT_ISSUPERSONIC: flatbuffers::VOffsetT = 12;
            pub const VT_ISBOT: flatbuffers::VOffsetT = 14;
            pub const VT_JUMPED: flatbuffers::VOffsetT = 16;
            pub const VT_DOUBLEJUMPED: flatbuffers::VOffsetT = 18;
            pub const VT_NAME: flatbuffers::VOffsetT = 20;
            pub const VT_TEAM: flatbuffers::VOffsetT = 22;
            pub const VT_BOOST: flatbuffers::VOffsetT = 24;
            pub const VT_HITBOX: flatbuffers::VOffsetT = 26;

            #[inline]
            pub fn physics(&self) -> Option<Physics<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Physics<'a>>>(PlayerInfo::VT_PHYSICS, None)
            }
            #[inline]
            pub fn scoreInfo(&self) -> Option<ScoreInfo<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ScoreInfo<'a>>>(
                        PlayerInfo::VT_SCOREINFO,
                        None,
                    )
            }
            #[inline]
            pub fn isDemolished(&self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_ISDEMOLISHED, Some(false))
                    .unwrap()
            }
            /// True if your wheels are on the ground, the wall, or the ceiling.
            /// False if you're midair or turtling.
            #[inline]
            pub fn hasWheelContact(&self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_HASWHEELCONTACT, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn isSupersonic(&self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_ISSUPERSONIC, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn isBot(&self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_ISBOT, Some(false))
                    .unwrap()
            }
            /// True if the player has jumped. Falling off the ceiling / driving
            /// off the goal post does not count.
            #[inline]
            pub fn jumped(&self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_JUMPED, Some(false))
                    .unwrap()
            }
            ///  True if player has double jumped. False does not mean you have
            /// a jump remaining, because the  aerial timer can run
            /// out, and that doesn't affect this flag.
            #[inline]
            pub fn doubleJumped(&self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_DOUBLEJUMPED, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PlayerInfo::VT_NAME, None)
            }
            #[inline]
            pub fn team(&self) -> i32 {
                self._tab.get::<i32>(PlayerInfo::VT_TEAM, Some(0)).unwrap()
            }
            #[inline]
            pub fn boost(&self) -> i32 {
                self._tab.get::<i32>(PlayerInfo::VT_BOOST, Some(0)).unwrap()
            }
            #[inline]
            pub fn hitbox(&self) -> Option<BoxShape<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<BoxShape<'a>>>(PlayerInfo::VT_HITBOX, None)
            }
        }

        pub struct PlayerInfoArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
            pub scoreInfo: Option<flatbuffers::WIPOffset<ScoreInfo<'a>>>,
            pub isDemolished: bool,
            pub hasWheelContact: bool,
            pub isSupersonic: bool,
            pub isBot: bool,
            pub jumped: bool,
            pub doubleJumped: bool,
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub team: i32,
            pub boost: i32,
            pub hitbox: Option<flatbuffers::WIPOffset<BoxShape<'a>>>,
        }
        impl<'a> Default for PlayerInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerInfoArgs {
                    physics: None,
                    scoreInfo: None,
                    isDemolished: false,
                    hasWheelContact: false,
                    isSupersonic: false,
                    isBot: false,
                    jumped: false,
                    doubleJumped: false,
                    name: None,
                    team: 0,
                    boost: 0,
                    hitbox: None,
                }
            }
        }
        pub struct PlayerInfoBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics<'_>>>(
                        PlayerInfo::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_scoreInfo(&mut self, scoreInfo: flatbuffers::WIPOffset<ScoreInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ScoreInfo<'_>>>(
                        PlayerInfo::VT_SCOREINFO,
                        scoreInfo,
                    );
            }
            #[inline]
            pub fn add_isDemolished(&mut self, isDemolished: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISDEMOLISHED, isDemolished, false);
            }
            #[inline]
            pub fn add_hasWheelContact(&mut self, hasWheelContact: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_HASWHEELCONTACT, hasWheelContact, false);
            }
            #[inline]
            pub fn add_isSupersonic(&mut self, isSupersonic: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISSUPERSONIC, isSupersonic, false);
            }
            #[inline]
            pub fn add_isBot(&mut self, isBot: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISBOT, isBot, false);
            }
            #[inline]
            pub fn add_jumped(&mut self, jumped: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_JUMPED, jumped, false);
            }
            #[inline]
            pub fn add_doubleJumped(&mut self, doubleJumped: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_DOUBLEJUMPED, doubleJumped, false);
            }
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(PlayerInfo::VT_NAME, name);
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_.push_slot::<i32>(PlayerInfo::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: i32) {
                self.fbb_.push_slot::<i32>(PlayerInfo::VT_BOOST, boost, 0);
            }
            #[inline]
            pub fn add_hitbox(&mut self, hitbox: flatbuffers::WIPOffset<BoxShape<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<BoxShape<'_>>>(
                        PlayerInfo::VT_HITBOX,
                        hitbox,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DropShotBallInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DropShotBallInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DropShotBallInfo<'a> {
            type Inner = DropShotBallInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DropShotBallInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DropShotBallInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DropShotBallInfoArgs,
            ) -> flatbuffers::WIPOffset<DropShotBallInfo<'bldr>> {
                let mut builder = DropShotBallInfoBuilder::new(_fbb);
                builder.add_forceAccumRecent(args.forceAccumRecent);
                builder.add_damageIndex(args.damageIndex);
                builder.add_absorbedForce(args.absorbedForce);
                builder.finish()
            }

            pub const VT_ABSORBEDFORCE: flatbuffers::VOffsetT = 4;
            pub const VT_DAMAGEINDEX: flatbuffers::VOffsetT = 6;
            pub const VT_FORCEACCUMRECENT: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn absorbedForce(&self) -> f32 {
                self._tab
                    .get::<f32>(DropShotBallInfo::VT_ABSORBEDFORCE, Some(0.0))
                    .unwrap()
            }
            #[inline]
            pub fn damageIndex(&self) -> i32 {
                self._tab
                    .get::<i32>(DropShotBallInfo::VT_DAMAGEINDEX, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn forceAccumRecent(&self) -> f32 {
                self._tab
                    .get::<f32>(DropShotBallInfo::VT_FORCEACCUMRECENT, Some(0.0))
                    .unwrap()
            }
        }

        pub struct DropShotBallInfoArgs {
            pub absorbedForce: f32,
            pub damageIndex: i32,
            pub forceAccumRecent: f32,
        }
        impl<'a> Default for DropShotBallInfoArgs {
            #[inline]
            fn default() -> Self {
                DropShotBallInfoArgs {
                    absorbedForce: 0.0,
                    damageIndex: 0,
                    forceAccumRecent: 0.0,
                }
            }
        }
        pub struct DropShotBallInfoBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DropShotBallInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_absorbedForce(&mut self, absorbedForce: f32) {
                self.fbb_
                    .push_slot::<f32>(DropShotBallInfo::VT_ABSORBEDFORCE, absorbedForce, 0.0);
            }
            #[inline]
            pub fn add_damageIndex(&mut self, damageIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(DropShotBallInfo::VT_DAMAGEINDEX, damageIndex, 0);
            }
            #[inline]
            pub fn add_forceAccumRecent(&mut self, forceAccumRecent: f32) {
                self.fbb_.push_slot::<f32>(
                    DropShotBallInfo::VT_FORCEACCUMRECENT,
                    forceAccumRecent,
                    0.0,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DropShotBallInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DropShotBallInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DropShotBallInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BallInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BallInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BallInfo<'a> {
            type Inner = BallInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BallInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BallInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BallInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<BallInfo<'bldr>> {
                let mut builder = BallInfoBuilder::new(_fbb);
                if let Some(x) = args.shape {
                    builder.add_shape(x);
                }
                if let Some(x) = args.dropShotInfo {
                    builder.add_dropShotInfo(x);
                }
                if let Some(x) = args.latestTouch {
                    builder.add_latestTouch(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.add_shape_type(args.shape_type);
                builder.finish()
            }

            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_LATESTTOUCH: flatbuffers::VOffsetT = 6;
            pub const VT_DROPSHOTINFO: flatbuffers::VOffsetT = 8;
            pub const VT_SHAPE_TYPE: flatbuffers::VOffsetT = 10;
            pub const VT_SHAPE: flatbuffers::VOffsetT = 12;

            #[inline]
            pub fn physics(&self) -> Option<Physics<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Physics<'a>>>(BallInfo::VT_PHYSICS, None)
            }
            #[inline]
            pub fn latestTouch(&self) -> Option<Touch<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Touch<'a>>>(BallInfo::VT_LATESTTOUCH, None)
            }
            #[inline]
            pub fn dropShotInfo(&self) -> Option<DropShotBallInfo<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DropShotBallInfo<'a>>>(
                        BallInfo::VT_DROPSHOTINFO,
                        None,
                    )
            }
            #[inline]
            pub fn shape_type(&self) -> CollisionShape {
                self._tab
                    .get::<CollisionShape>(BallInfo::VT_SHAPE_TYPE, Some(CollisionShape::NONE))
                    .unwrap()
            }
            #[inline]
            pub fn shape(&self) -> Option<flatbuffers::Table<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        BallInfo::VT_SHAPE,
                        None,
                    )
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn shape_as_box_shape(&'a self) -> Option<BoxShape<'_>> {
                if self.shape_type() == CollisionShape::BoxShape {
                    self.shape().map(|u| BoxShape::init_from_table(u))
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn shape_as_sphere_shape(&'a self) -> Option<SphereShape<'_>> {
                if self.shape_type() == CollisionShape::SphereShape {
                    self.shape().map(|u| SphereShape::init_from_table(u))
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn shape_as_cylinder_shape(&'a self) -> Option<CylinderShape<'_>> {
                if self.shape_type() == CollisionShape::CylinderShape {
                    self.shape().map(|u| CylinderShape::init_from_table(u))
                } else {
                    None
                }
            }
        }

        pub struct BallInfoArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
            pub latestTouch: Option<flatbuffers::WIPOffset<Touch<'a>>>,
            pub dropShotInfo: Option<flatbuffers::WIPOffset<DropShotBallInfo<'a>>>,
            pub shape_type: CollisionShape,
            pub shape: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for BallInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                BallInfoArgs {
                    physics: None,
                    latestTouch: None,
                    dropShotInfo: None,
                    shape_type: CollisionShape::NONE,
                    shape: None,
                }
            }
        }
        pub struct BallInfoBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BallInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics<'_>>>(
                        BallInfo::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_latestTouch(&mut self, latestTouch: flatbuffers::WIPOffset<Touch<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Touch<'_>>>(
                        BallInfo::VT_LATESTTOUCH,
                        latestTouch,
                    );
            }
            #[inline]
            pub fn add_dropShotInfo(
                &mut self,
                dropShotInfo: flatbuffers::WIPOffset<DropShotBallInfo<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DropShotBallInfo<'_>>>(
                        BallInfo::VT_DROPSHOTINFO,
                        dropShotInfo,
                    );
            }
            #[inline]
            pub fn add_shape_type(&mut self, shape_type: CollisionShape) {
                self.fbb_.push_slot::<CollisionShape>(
                    BallInfo::VT_SHAPE_TYPE,
                    shape_type,
                    CollisionShape::NONE,
                );
            }
            #[inline]
            pub fn add_shape(
                &mut self,
                shape: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(BallInfo::VT_SHAPE, shape);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BallInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BallInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BallInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BoostPadStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BoostPadState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BoostPadState<'a> {
            type Inner = BoostPadState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BoostPadState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BoostPadState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoostPadStateArgs,
            ) -> flatbuffers::WIPOffset<BoostPadState<'bldr>> {
                let mut builder = BoostPadStateBuilder::new(_fbb);
                builder.add_timer(args.timer);
                builder.add_isActive(args.isActive);
                builder.finish()
            }

            pub const VT_ISACTIVE: flatbuffers::VOffsetT = 4;
            pub const VT_TIMER: flatbuffers::VOffsetT = 6;

            /// True if the boost can be picked up
            #[inline]
            pub fn isActive(&self) -> bool {
                self._tab
                    .get::<bool>(BoostPadState::VT_ISACTIVE, Some(false))
                    .unwrap()
            }
            /// The number of seconds since the boost has been picked up, or 0.0
            /// if the boost is active.
            #[inline]
            pub fn timer(&self) -> f32 {
                self._tab
                    .get::<f32>(BoostPadState::VT_TIMER, Some(0.0))
                    .unwrap()
            }
        }

        pub struct BoostPadStateArgs {
            pub isActive: bool,
            pub timer: f32,
        }
        impl<'a> Default for BoostPadStateArgs {
            #[inline]
            fn default() -> Self {
                BoostPadStateArgs {
                    isActive: false,
                    timer: 0.0,
                }
            }
        }
        pub struct BoostPadStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoostPadStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_isActive(&mut self, isActive: bool) {
                self.fbb_
                    .push_slot::<bool>(BoostPadState::VT_ISACTIVE, isActive, false);
            }
            #[inline]
            pub fn add_timer(&mut self, timer: f32) {
                self.fbb_
                    .push_slot::<f32>(BoostPadState::VT_TIMER, timer, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BoostPadStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoostPadStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BoostPadState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DropshotTileOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DropshotTile<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DropshotTile<'a> {
            type Inner = DropshotTile<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DropshotTile<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DropshotTile { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DropshotTileArgs,
            ) -> flatbuffers::WIPOffset<DropshotTile<'bldr>> {
                let mut builder = DropshotTileBuilder::new(_fbb);
                builder.add_tileState(args.tileState);
                builder.finish()
            }

            pub const VT_TILESTATE: flatbuffers::VOffsetT = 4;

            /// The amount of damage the tile has sustained.
            #[inline]
            pub fn tileState(&self) -> TileState {
                self._tab
                    .get::<TileState>(DropshotTile::VT_TILESTATE, Some(TileState::Unknown))
                    .unwrap()
            }
        }

        pub struct DropshotTileArgs {
            pub tileState: TileState,
        }
        impl<'a> Default for DropshotTileArgs {
            #[inline]
            fn default() -> Self {
                DropshotTileArgs {
                    tileState: TileState::Unknown,
                }
            }
        }
        pub struct DropshotTileBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DropshotTileBuilder<'a, 'b> {
            #[inline]
            pub fn add_tileState(&mut self, tileState: TileState) {
                self.fbb_.push_slot::<TileState>(
                    DropshotTile::VT_TILESTATE,
                    tileState,
                    TileState::Unknown,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DropshotTileBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DropshotTileBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DropshotTile<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum GameInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct GameInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GameInfo<'a> {
            type Inner = GameInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> GameInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GameInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GameInfoArgs,
            ) -> flatbuffers::WIPOffset<GameInfo<'bldr>> {
                let mut builder = GameInfoBuilder::new(_fbb);
                builder.add_gameSpeed(args.gameSpeed);
                builder.add_worldGravityZ(args.worldGravityZ);
                builder.add_gameTimeRemaining(args.gameTimeRemaining);
                builder.add_secondsElapsed(args.secondsElapsed);
                builder.add_isMatchEnded(args.isMatchEnded);
                builder.add_isKickoffPause(args.isKickoffPause);
                builder.add_isRoundActive(args.isRoundActive);
                builder.add_isUnlimitedTime(args.isUnlimitedTime);
                builder.add_isOvertime(args.isOvertime);
                builder.finish()
            }

            pub const VT_SECONDSELAPSED: flatbuffers::VOffsetT = 4;
            pub const VT_GAMETIMEREMAINING: flatbuffers::VOffsetT = 6;
            pub const VT_ISOVERTIME: flatbuffers::VOffsetT = 8;
            pub const VT_ISUNLIMITEDTIME: flatbuffers::VOffsetT = 10;
            pub const VT_ISROUNDACTIVE: flatbuffers::VOffsetT = 12;
            pub const VT_ISKICKOFFPAUSE: flatbuffers::VOffsetT = 14;
            pub const VT_ISMATCHENDED: flatbuffers::VOffsetT = 16;
            pub const VT_WORLDGRAVITYZ: flatbuffers::VOffsetT = 18;
            pub const VT_GAMESPEED: flatbuffers::VOffsetT = 20;

            #[inline]
            pub fn secondsElapsed(&self) -> f32 {
                self._tab
                    .get::<f32>(GameInfo::VT_SECONDSELAPSED, Some(0.0))
                    .unwrap()
            }
            #[inline]
            pub fn gameTimeRemaining(&self) -> f32 {
                self._tab
                    .get::<f32>(GameInfo::VT_GAMETIMEREMAINING, Some(0.0))
                    .unwrap()
            }
            #[inline]
            pub fn isOvertime(&self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISOVERTIME, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn isUnlimitedTime(&self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISUNLIMITEDTIME, Some(false))
                    .unwrap()
            }
            /// True when cars are allowed to move, and during the pause menu.
            /// False during replays.
            #[inline]
            pub fn isRoundActive(&self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISROUNDACTIVE, Some(false))
                    .unwrap()
            }
            /// True when the clock is paused due to kickoff, but false during
            /// kickoff countdown. In other words, it is true
            /// while cars can move during kickoff. Note that if both players
            /// sit still, game clock start and this will become false.
            #[inline]
            pub fn isKickoffPause(&self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISKICKOFFPAUSE, Some(false))
                    .unwrap()
            }
            /// Turns true after final replay, the moment the 'winner' screen
            /// appears. Remains true during next match countdown.
            /// Turns false again the moment the 'choose team' screen appears.
            #[inline]
            pub fn isMatchEnded(&self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISMATCHENDED, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn worldGravityZ(&self) -> f32 {
                self._tab
                    .get::<f32>(GameInfo::VT_WORLDGRAVITYZ, Some(0.0))
                    .unwrap()
            }
            /// Game speed multiplier, 1.0 is regular game speed.
            #[inline]
            pub fn gameSpeed(&self) -> f32 {
                self._tab
                    .get::<f32>(GameInfo::VT_GAMESPEED, Some(0.0))
                    .unwrap()
            }
        }

        pub struct GameInfoArgs {
            pub secondsElapsed: f32,
            pub gameTimeRemaining: f32,
            pub isOvertime: bool,
            pub isUnlimitedTime: bool,
            pub isRoundActive: bool,
            pub isKickoffPause: bool,
            pub isMatchEnded: bool,
            pub worldGravityZ: f32,
            pub gameSpeed: f32,
        }
        impl<'a> Default for GameInfoArgs {
            #[inline]
            fn default() -> Self {
                GameInfoArgs {
                    secondsElapsed: 0.0,
                    gameTimeRemaining: 0.0,
                    isOvertime: false,
                    isUnlimitedTime: false,
                    isRoundActive: false,
                    isKickoffPause: false,
                    isMatchEnded: false,
                    worldGravityZ: 0.0,
                    gameSpeed: 0.0,
                }
            }
        }
        pub struct GameInfoBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GameInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_secondsElapsed(&mut self, secondsElapsed: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_SECONDSELAPSED, secondsElapsed, 0.0);
            }
            #[inline]
            pub fn add_gameTimeRemaining(&mut self, gameTimeRemaining: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_GAMETIMEREMAINING, gameTimeRemaining, 0.0);
            }
            #[inline]
            pub fn add_isOvertime(&mut self, isOvertime: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISOVERTIME, isOvertime, false);
            }
            #[inline]
            pub fn add_isUnlimitedTime(&mut self, isUnlimitedTime: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISUNLIMITEDTIME, isUnlimitedTime, false);
            }
            #[inline]
            pub fn add_isRoundActive(&mut self, isRoundActive: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISROUNDACTIVE, isRoundActive, false);
            }
            #[inline]
            pub fn add_isKickoffPause(&mut self, isKickoffPause: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISKICKOFFPAUSE, isKickoffPause, false);
            }
            #[inline]
            pub fn add_isMatchEnded(&mut self, isMatchEnded: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISMATCHENDED, isMatchEnded, false);
            }
            #[inline]
            pub fn add_worldGravityZ(&mut self, worldGravityZ: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_WORLDGRAVITYZ, worldGravityZ, 0.0);
            }
            #[inline]
            pub fn add_gameSpeed(&mut self, gameSpeed: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_GAMESPEED, gameSpeed, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GameInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GameInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GameInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum TeamInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct TeamInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TeamInfo<'a> {
            type Inner = TeamInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> TeamInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TeamInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TeamInfoArgs,
            ) -> flatbuffers::WIPOffset<TeamInfo<'bldr>> {
                let mut builder = TeamInfoBuilder::new(_fbb);
                builder.add_score(args.score);
                builder.add_teamIndex(args.teamIndex);
                builder.finish()
            }

            pub const VT_TEAMINDEX: flatbuffers::VOffsetT = 4;
            pub const VT_SCORE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn teamIndex(&self) -> i32 {
                self._tab
                    .get::<i32>(TeamInfo::VT_TEAMINDEX, Some(0))
                    .unwrap()
            }
            /// number of goals scored.
            #[inline]
            pub fn score(&self) -> i32 {
                self._tab.get::<i32>(TeamInfo::VT_SCORE, Some(0)).unwrap()
            }
        }

        pub struct TeamInfoArgs {
            pub teamIndex: i32,
            pub score: i32,
        }
        impl<'a> Default for TeamInfoArgs {
            #[inline]
            fn default() -> Self {
                TeamInfoArgs {
                    teamIndex: 0,
                    score: 0,
                }
            }
        }
        pub struct TeamInfoBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TeamInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_teamIndex(&mut self, teamIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(TeamInfo::VT_TEAMINDEX, teamIndex, 0);
            }
            #[inline]
            pub fn add_score(&mut self, score: i32) {
                self.fbb_.push_slot::<i32>(TeamInfo::VT_SCORE, score, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TeamInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TeamInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TeamInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum GameTickPacketOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct GameTickPacket<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GameTickPacket<'a> {
            type Inner = GameTickPacket<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> GameTickPacket<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GameTickPacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GameTickPacketArgs<'args>,
            ) -> flatbuffers::WIPOffset<GameTickPacket<'bldr>> {
                let mut builder = GameTickPacketBuilder::new(_fbb);
                if let Some(x) = args.teams {
                    builder.add_teams(x);
                }
                if let Some(x) = args.tileInformation {
                    builder.add_tileInformation(x);
                }
                if let Some(x) = args.gameInfo {
                    builder.add_gameInfo(x);
                }
                if let Some(x) = args.ball {
                    builder.add_ball(x);
                }
                if let Some(x) = args.boostPadStates {
                    builder.add_boostPadStates(x);
                }
                if let Some(x) = args.players {
                    builder.add_players(x);
                }
                builder.finish()
            }

            pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;
            pub const VT_BOOSTPADSTATES: flatbuffers::VOffsetT = 6;
            pub const VT_BALL: flatbuffers::VOffsetT = 8;
            pub const VT_GAMEINFO: flatbuffers::VOffsetT = 10;
            pub const VT_TILEINFORMATION: flatbuffers::VOffsetT = 12;
            pub const VT_TEAMS: flatbuffers::VOffsetT = 14;

            #[inline]
            pub fn players(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>,
                >>(GameTickPacket::VT_PLAYERS, None)
            }
            #[inline]
            pub fn boostPadStates(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoostPadState<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoostPadState<'a>>>,
                >>(GameTickPacket::VT_BOOSTPADSTATES, None)
            }
            #[inline]
            pub fn ball(&self) -> Option<BallInfo<'a>> {
                self._tab.get::<flatbuffers::ForwardsUOffset<BallInfo<'a>>>(
                    GameTickPacket::VT_BALL,
                    None,
                )
            }
            #[inline]
            pub fn gameInfo(&self) -> Option<GameInfo<'a>> {
                self._tab.get::<flatbuffers::ForwardsUOffset<GameInfo<'a>>>(
                    GameTickPacket::VT_GAMEINFO,
                    None,
                )
            }
            #[inline]
            pub fn tileInformation(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DropshotTile<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DropshotTile<'a>>>,
                >>(GameTickPacket::VT_TILEINFORMATION, None)
            }
            #[inline]
            pub fn teams(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TeamInfo<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TeamInfo<'a>>>,
                >>(GameTickPacket::VT_TEAMS, None)
            }
        }

        pub struct GameTickPacketArgs<'a> {
            pub players: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>,
                >,
            >,
            pub boostPadStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPadState<'a>>>,
                >,
            >,
            pub ball: Option<flatbuffers::WIPOffset<BallInfo<'a>>>,
            pub gameInfo: Option<flatbuffers::WIPOffset<GameInfo<'a>>>,
            pub tileInformation: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DropshotTile<'a>>>,
                >,
            >,
            pub teams: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamInfo<'a>>>,
                >,
            >,
        }
        impl<'a> Default for GameTickPacketArgs<'a> {
            #[inline]
            fn default() -> Self {
                GameTickPacketArgs {
                    players: None,
                    boostPadStates: None,
                    ball: None,
                    gameInfo: None,
                    tileInformation: None,
                    teams: None,
                }
            }
        }
        pub struct GameTickPacketBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GameTickPacketBuilder<'a, 'b> {
            #[inline]
            pub fn add_players(
                &mut self,
                players: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlayerInfo<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_PLAYERS,
                    players,
                );
            }
            #[inline]
            pub fn add_boostPadStates(
                &mut self,
                boostPadStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BoostPadState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_BOOSTPADSTATES,
                    boostPadStates,
                );
            }
            #[inline]
            pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<BallInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<BallInfo<'_>>>(
                        GameTickPacket::VT_BALL,
                        ball,
                    );
            }
            #[inline]
            pub fn add_gameInfo(&mut self, gameInfo: flatbuffers::WIPOffset<GameInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<GameInfo<'_>>>(
                        GameTickPacket::VT_GAMEINFO,
                        gameInfo,
                    );
            }
            #[inline]
            pub fn add_tileInformation(
                &mut self,
                tileInformation: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DropshotTile<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_TILEINFORMATION,
                    tileInformation,
                );
            }
            #[inline]
            pub fn add_teams(
                &mut self,
                teams: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TeamInfo<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(GameTickPacket::VT_TEAMS, teams);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GameTickPacketBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GameTickPacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GameTickPacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// The state of a rigid body in Rocket League's physics engine.
        /// This gets updated in time with the physics tick, not the rendering
        /// framerate. The frame field will be incremented every time
        /// the physics engine ticks.
        pub enum RigidBodyStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RigidBodyState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RigidBodyState<'a> {
            type Inner = RigidBodyState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RigidBodyState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RigidBodyState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RigidBodyStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<RigidBodyState<'bldr>> {
                let mut builder = RigidBodyStateBuilder::new(_fbb);
                if let Some(x) = args.angularVelocity {
                    builder.add_angularVelocity(x);
                }
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_frame(args.frame);
                builder.finish()
            }

            pub const VT_FRAME: flatbuffers::VOffsetT = 4;
            pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 8;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 10;
            pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 12;

            #[inline]
            pub fn frame(&self) -> i32 {
                self._tab
                    .get::<i32>(RigidBodyState::VT_FRAME, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(RigidBodyState::VT_LOCATION, None)
            }
            #[inline]
            pub fn rotation(&self) -> Option<&'a Quaternion> {
                self._tab
                    .get::<Quaternion>(RigidBodyState::VT_ROTATION, None)
            }
            #[inline]
            pub fn velocity(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(RigidBodyState::VT_VELOCITY, None)
            }
            #[inline]
            pub fn angularVelocity(&self) -> Option<&'a Vector3> {
                self._tab
                    .get::<Vector3>(RigidBodyState::VT_ANGULARVELOCITY, None)
            }
        }

        pub struct RigidBodyStateArgs<'a> {
            pub frame: i32,
            pub location: Option<&'a Vector3>,
            pub rotation: Option<&'a Quaternion>,
            pub velocity: Option<&'a Vector3>,
            pub angularVelocity: Option<&'a Vector3>,
        }
        impl<'a> Default for RigidBodyStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                RigidBodyStateArgs {
                    frame: 0,
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }
        pub struct RigidBodyStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RigidBodyStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_frame(&mut self, frame: i32) {
                self.fbb_
                    .push_slot::<i32>(RigidBodyState::VT_FRAME, frame, 0);
            }
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RigidBodyState::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: &'b Quaternion) {
                self.fbb_
                    .push_slot_always::<&Quaternion>(RigidBodyState::VT_ROTATION, rotation);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RigidBodyState::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn add_angularVelocity(&mut self, angularVelocity: &'b Vector3) {
                self.fbb_.push_slot_always::<&Vector3>(
                    RigidBodyState::VT_ANGULARVELOCITY,
                    angularVelocity,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RigidBodyStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RigidBodyStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RigidBodyState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// Rigid body state for a player / car in the game. Includes the latest
        /// controller input, which is otherwise difficult to correlate with
        /// consequences.
        pub enum PlayerRigidBodyStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PlayerRigidBodyState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerRigidBodyState<'a> {
            type Inner = PlayerRigidBodyState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PlayerRigidBodyState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerRigidBodyState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerRigidBodyStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerRigidBodyState<'bldr>> {
                let mut builder = PlayerRigidBodyStateBuilder::new(_fbb);
                if let Some(x) = args.input {
                    builder.add_input(x);
                }
                if let Some(x) = args.state {
                    builder.add_state(x);
                }
                builder.finish()
            }

            pub const VT_STATE: flatbuffers::VOffsetT = 4;
            pub const VT_INPUT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn state(&self) -> Option<RigidBodyState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<RigidBodyState<'a>>>(
                        PlayerRigidBodyState::VT_STATE,
                        None,
                    )
            }
            #[inline]
            pub fn input(&self) -> Option<ControllerState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ControllerState<'a>>>(
                        PlayerRigidBodyState::VT_INPUT,
                        None,
                    )
            }
        }

        pub struct PlayerRigidBodyStateArgs<'a> {
            pub state: Option<flatbuffers::WIPOffset<RigidBodyState<'a>>>,
            pub input: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
        }
        impl<'a> Default for PlayerRigidBodyStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerRigidBodyStateArgs {
                    state: None,
                    input: None,
                }
            }
        }
        pub struct PlayerRigidBodyStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerRigidBodyStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_state(&mut self, state: flatbuffers::WIPOffset<RigidBodyState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<RigidBodyState<'_>>>(
                        PlayerRigidBodyState::VT_STATE,
                        state,
                    );
            }
            #[inline]
            pub fn add_input(&mut self, input: flatbuffers::WIPOffset<ControllerState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ControllerState<'_>>>(
                        PlayerRigidBodyState::VT_INPUT,
                        input,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerRigidBodyStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerRigidBodyStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerRigidBodyState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// Rigid body state for the ball.
        pub enum BallRigidBodyStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BallRigidBodyState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BallRigidBodyState<'a> {
            type Inner = BallRigidBodyState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BallRigidBodyState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BallRigidBodyState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BallRigidBodyStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<BallRigidBodyState<'bldr>> {
                let mut builder = BallRigidBodyStateBuilder::new(_fbb);
                if let Some(x) = args.state {
                    builder.add_state(x);
                }
                builder.finish()
            }

            pub const VT_STATE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn state(&self) -> Option<RigidBodyState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<RigidBodyState<'a>>>(
                        BallRigidBodyState::VT_STATE,
                        None,
                    )
            }
        }

        pub struct BallRigidBodyStateArgs<'a> {
            pub state: Option<flatbuffers::WIPOffset<RigidBodyState<'a>>>,
        }
        impl<'a> Default for BallRigidBodyStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                BallRigidBodyStateArgs { state: None }
            }
        }
        pub struct BallRigidBodyStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BallRigidBodyStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_state(&mut self, state: flatbuffers::WIPOffset<RigidBodyState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<RigidBodyState<'_>>>(
                        BallRigidBodyState::VT_STATE,
                        state,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BallRigidBodyStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BallRigidBodyStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BallRigidBodyState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// Contains all rigid body state information.
        pub enum RigidBodyTickOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RigidBodyTick<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RigidBodyTick<'a> {
            type Inner = RigidBodyTick<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RigidBodyTick<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RigidBodyTick { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RigidBodyTickArgs<'args>,
            ) -> flatbuffers::WIPOffset<RigidBodyTick<'bldr>> {
                let mut builder = RigidBodyTickBuilder::new(_fbb);
                if let Some(x) = args.players {
                    builder.add_players(x);
                }
                if let Some(x) = args.ball {
                    builder.add_ball(x);
                }
                builder.finish()
            }

            pub const VT_BALL: flatbuffers::VOffsetT = 4;
            pub const VT_PLAYERS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn ball(&self) -> Option<BallRigidBodyState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<BallRigidBodyState<'a>>>(
                        RigidBodyTick::VT_BALL,
                        None,
                    )
            }
            #[inline]
            pub fn players(
                &self,
            ) -> Option<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'a>>>,
            > {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'a>>>,
                >>(RigidBodyTick::VT_PLAYERS, None)
            }
        }

        pub struct RigidBodyTickArgs<'a> {
            pub ball: Option<flatbuffers::WIPOffset<BallRigidBodyState<'a>>>,
            pub players: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'a>>>,
                >,
            >,
        }
        impl<'a> Default for RigidBodyTickArgs<'a> {
            #[inline]
            fn default() -> Self {
                RigidBodyTickArgs {
                    ball: None,
                    players: None,
                }
            }
        }
        pub struct RigidBodyTickBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RigidBodyTickBuilder<'a, 'b> {
            #[inline]
            pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<BallRigidBodyState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<BallRigidBodyState<'_>>>(
                        RigidBodyTick::VT_BALL,
                        ball,
                    );
            }
            #[inline]
            pub fn add_players(
                &mut self,
                players: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    RigidBodyTick::VT_PLAYERS,
                    players,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RigidBodyTickBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RigidBodyTickBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RigidBodyTick<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum GoalInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct GoalInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GoalInfo<'a> {
            type Inner = GoalInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> GoalInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GoalInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GoalInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<GoalInfo<'bldr>> {
                let mut builder = GoalInfoBuilder::new(_fbb);
                builder.add_height(args.height);
                builder.add_width(args.width);
                if let Some(x) = args.direction {
                    builder.add_direction(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_teamNum(args.teamNum);
                builder.finish()
            }

            pub const VT_TEAMNUM: flatbuffers::VOffsetT = 4;
            pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
            pub const VT_DIRECTION: flatbuffers::VOffsetT = 8;
            pub const VT_WIDTH: flatbuffers::VOffsetT = 10;
            pub const VT_HEIGHT: flatbuffers::VOffsetT = 12;

            #[inline]
            pub fn teamNum(&self) -> i32 {
                self._tab.get::<i32>(GoalInfo::VT_TEAMNUM, Some(0)).unwrap()
            }
            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(GoalInfo::VT_LOCATION, None)
            }
            #[inline]
            pub fn direction(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(GoalInfo::VT_DIRECTION, None)
            }
            #[inline]
            pub fn width(&self) -> f32 {
                self._tab.get::<f32>(GoalInfo::VT_WIDTH, Some(0.0)).unwrap()
            }
            #[inline]
            pub fn height(&self) -> f32 {
                self._tab
                    .get::<f32>(GoalInfo::VT_HEIGHT, Some(0.0))
                    .unwrap()
            }
        }

        pub struct GoalInfoArgs<'a> {
            pub teamNum: i32,
            pub location: Option<&'a Vector3>,
            pub direction: Option<&'a Vector3>,
            pub width: f32,
            pub height: f32,
        }
        impl<'a> Default for GoalInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                GoalInfoArgs {
                    teamNum: 0,
                    location: None,
                    direction: None,
                    width: 0.0,
                    height: 0.0,
                }
            }
        }
        pub struct GoalInfoBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GoalInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_teamNum(&mut self, teamNum: i32) {
                self.fbb_.push_slot::<i32>(GoalInfo::VT_TEAMNUM, teamNum, 0);
            }
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(GoalInfo::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_direction(&mut self, direction: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(GoalInfo::VT_DIRECTION, direction);
            }
            #[inline]
            pub fn add_width(&mut self, width: f32) {
                self.fbb_.push_slot::<f32>(GoalInfo::VT_WIDTH, width, 0.0);
            }
            #[inline]
            pub fn add_height(&mut self, height: f32) {
                self.fbb_.push_slot::<f32>(GoalInfo::VT_HEIGHT, height, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GoalInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GoalInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GoalInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BoostPadOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BoostPad<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BoostPad<'a> {
            type Inner = BoostPad<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BoostPad<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BoostPad { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoostPadArgs<'args>,
            ) -> flatbuffers::WIPOffset<BoostPad<'bldr>> {
                let mut builder = BoostPadBuilder::new(_fbb);
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_isFullBoost(args.isFullBoost);
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ISFULLBOOST: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(BoostPad::VT_LOCATION, None)
            }
            #[inline]
            pub fn isFullBoost(&self) -> bool {
                self._tab
                    .get::<bool>(BoostPad::VT_ISFULLBOOST, Some(false))
                    .unwrap()
            }
        }

        pub struct BoostPadArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub isFullBoost: bool,
        }
        impl<'a> Default for BoostPadArgs<'a> {
            #[inline]
            fn default() -> Self {
                BoostPadArgs {
                    location: None,
                    isFullBoost: false,
                }
            }
        }
        pub struct BoostPadBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoostPadBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(BoostPad::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_isFullBoost(&mut self, isFullBoost: bool) {
                self.fbb_
                    .push_slot::<bool>(BoostPad::VT_ISFULLBOOST, isFullBoost, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BoostPadBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoostPadBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BoostPad<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum FieldInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct FieldInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FieldInfo<'a> {
            type Inner = FieldInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> FieldInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FieldInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args FieldInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<FieldInfo<'bldr>> {
                let mut builder = FieldInfoBuilder::new(_fbb);
                if let Some(x) = args.goals {
                    builder.add_goals(x);
                }
                if let Some(x) = args.boostPads {
                    builder.add_boostPads(x);
                }
                builder.finish()
            }

            pub const VT_BOOSTPADS: flatbuffers::VOffsetT = 4;
            pub const VT_GOALS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn boostPads(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoostPad<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoostPad<'a>>>,
                >>(FieldInfo::VT_BOOSTPADS, None)
            }
            #[inline]
            pub fn goals(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GoalInfo<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GoalInfo<'a>>>,
                >>(FieldInfo::VT_GOALS, None)
            }
        }

        pub struct FieldInfoArgs<'a> {
            pub boostPads: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPad<'a>>>,
                >,
            >,
            pub goals: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GoalInfo<'a>>>,
                >,
            >,
        }
        impl<'a> Default for FieldInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                FieldInfoArgs {
                    boostPads: None,
                    goals: None,
                }
            }
        }
        pub struct FieldInfoBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> FieldInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_boostPads(
                &mut self,
                boostPads: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BoostPad<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    FieldInfo::VT_BOOSTPADS,
                    boostPads,
                );
            }
            #[inline]
            pub fn add_goals(
                &mut self,
                goals: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<GoalInfo<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FieldInfo::VT_GOALS, goals);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> FieldInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                FieldInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FieldInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum Vector3PartialOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Vector3Partial<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Vector3Partial<'a> {
            type Inner = Vector3Partial<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> Vector3Partial<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Vector3Partial { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args Vector3PartialArgs<'args>,
            ) -> flatbuffers::WIPOffset<Vector3Partial<'bldr>> {
                let mut builder = Vector3PartialBuilder::new(_fbb);
                if let Some(x) = args.z {
                    builder.add_z(x);
                }
                if let Some(x) = args.y {
                    builder.add_y(x);
                }
                if let Some(x) = args.x {
                    builder.add_x(x);
                }
                builder.finish()
            }

            pub const VT_X: flatbuffers::VOffsetT = 4;
            pub const VT_Y: flatbuffers::VOffsetT = 6;
            pub const VT_Z: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn x(&self) -> Option<&'a Float> {
                self._tab.get::<Float>(Vector3Partial::VT_X, None)
            }
            #[inline]
            pub fn y(&self) -> Option<&'a Float> {
                self._tab.get::<Float>(Vector3Partial::VT_Y, None)
            }
            #[inline]
            pub fn z(&self) -> Option<&'a Float> {
                self._tab.get::<Float>(Vector3Partial::VT_Z, None)
            }
        }

        pub struct Vector3PartialArgs<'a> {
            pub x: Option<&'a Float>,
            pub y: Option<&'a Float>,
            pub z: Option<&'a Float>,
        }
        impl<'a> Default for Vector3PartialArgs<'a> {
            #[inline]
            fn default() -> Self {
                Vector3PartialArgs {
                    x: None,
                    y: None,
                    z: None,
                }
            }
        }
        pub struct Vector3PartialBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> Vector3PartialBuilder<'a, 'b> {
            #[inline]
            pub fn add_x(&mut self, x: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_X, x);
            }
            #[inline]
            pub fn add_y(&mut self, y: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_Y, y);
            }
            #[inline]
            pub fn add_z(&mut self, z: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_Z, z);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> Vector3PartialBuilder<'a, 'b> {
                let start = _fbb.start_table();
                Vector3PartialBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Vector3Partial<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum RotatorPartialOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RotatorPartial<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RotatorPartial<'a> {
            type Inner = RotatorPartial<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RotatorPartial<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RotatorPartial { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RotatorPartialArgs<'args>,
            ) -> flatbuffers::WIPOffset<RotatorPartial<'bldr>> {
                let mut builder = RotatorPartialBuilder::new(_fbb);
                if let Some(x) = args.roll {
                    builder.add_roll(x);
                }
                if let Some(x) = args.yaw {
                    builder.add_yaw(x);
                }
                if let Some(x) = args.pitch {
                    builder.add_pitch(x);
                }
                builder.finish()
            }

            pub const VT_PITCH: flatbuffers::VOffsetT = 4;
            pub const VT_YAW: flatbuffers::VOffsetT = 6;
            pub const VT_ROLL: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn pitch(&self) -> Option<&'a Float> {
                self._tab.get::<Float>(RotatorPartial::VT_PITCH, None)
            }
            #[inline]
            pub fn yaw(&self) -> Option<&'a Float> {
                self._tab.get::<Float>(RotatorPartial::VT_YAW, None)
            }
            #[inline]
            pub fn roll(&self) -> Option<&'a Float> {
                self._tab.get::<Float>(RotatorPartial::VT_ROLL, None)
            }
        }

        pub struct RotatorPartialArgs<'a> {
            pub pitch: Option<&'a Float>,
            pub yaw: Option<&'a Float>,
            pub roll: Option<&'a Float>,
        }
        impl<'a> Default for RotatorPartialArgs<'a> {
            #[inline]
            fn default() -> Self {
                RotatorPartialArgs {
                    pitch: None,
                    yaw: None,
                    roll: None,
                }
            }
        }
        pub struct RotatorPartialBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RotatorPartialBuilder<'a, 'b> {
            #[inline]
            pub fn add_pitch(&mut self, pitch: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_PITCH, pitch);
            }
            #[inline]
            pub fn add_yaw(&mut self, yaw: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_YAW, yaw);
            }
            #[inline]
            pub fn add_roll(&mut self, roll: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_ROLL, roll);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RotatorPartialBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RotatorPartialBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RotatorPartial<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredPhysicsOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredPhysics<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredPhysics<'a> {
            type Inner = DesiredPhysics<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredPhysics<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredPhysics { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredPhysicsArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredPhysics<'bldr>> {
                let mut builder = DesiredPhysicsBuilder::new(_fbb);
                if let Some(x) = args.angularVelocity {
                    builder.add_angularVelocity(x);
                }
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub fn location(&self) -> Option<Vector3Partial<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Vector3Partial<'a>>>(
                        DesiredPhysics::VT_LOCATION,
                        None,
                    )
            }
            #[inline]
            pub fn rotation(&self) -> Option<RotatorPartial<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<RotatorPartial<'a>>>(
                        DesiredPhysics::VT_ROTATION,
                        None,
                    )
            }
            #[inline]
            pub fn velocity(&self) -> Option<Vector3Partial<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Vector3Partial<'a>>>(
                        DesiredPhysics::VT_VELOCITY,
                        None,
                    )
            }
            #[inline]
            pub fn angularVelocity(&self) -> Option<Vector3Partial<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Vector3Partial<'a>>>(
                        DesiredPhysics::VT_ANGULARVELOCITY,
                        None,
                    )
            }
        }

        pub struct DesiredPhysicsArgs<'a> {
            pub location: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
            pub rotation: Option<flatbuffers::WIPOffset<RotatorPartial<'a>>>,
            pub velocity: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
            pub angularVelocity: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
        }
        impl<'a> Default for DesiredPhysicsArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredPhysicsArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }
        pub struct DesiredPhysicsBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredPhysicsBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: flatbuffers::WIPOffset<Vector3Partial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial<'_>>>(
                        DesiredPhysics::VT_LOCATION,
                        location,
                    );
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: flatbuffers::WIPOffset<RotatorPartial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<RotatorPartial<'_>>>(
                        DesiredPhysics::VT_ROTATION,
                        rotation,
                    );
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: flatbuffers::WIPOffset<Vector3Partial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial<'_>>>(
                        DesiredPhysics::VT_VELOCITY,
                        velocity,
                    );
            }
            #[inline]
            pub fn add_angularVelocity(
                &mut self,
                angularVelocity: flatbuffers::WIPOffset<Vector3Partial<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial<'_>>>(
                        DesiredPhysics::VT_ANGULARVELOCITY,
                        angularVelocity,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredPhysicsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredPhysicsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredPhysics<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredBallStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredBallState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredBallState<'a> {
            type Inner = DesiredBallState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredBallState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredBallState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredBallStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredBallState<'bldr>> {
                let mut builder = DesiredBallStateBuilder::new(_fbb);
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.finish()
            }

            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn physics(&self) -> Option<DesiredPhysics<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DesiredPhysics<'a>>>(
                        DesiredBallState::VT_PHYSICS,
                        None,
                    )
            }
        }

        pub struct DesiredBallStateArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<DesiredPhysics<'a>>>,
        }
        impl<'a> Default for DesiredBallStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredBallStateArgs { physics: None }
            }
        }
        pub struct DesiredBallStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredBallStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<DesiredPhysics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredPhysics<'_>>>(
                        DesiredBallState::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredBallStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredBallStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredBallState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredCarStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredCarState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredCarState<'a> {
            type Inner = DesiredCarState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredCarState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredCarState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredCarStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredCarState<'bldr>> {
                let mut builder = DesiredCarStateBuilder::new(_fbb);
                if let Some(x) = args.doubleJumped {
                    builder.add_doubleJumped(x);
                }
                if let Some(x) = args.jumped {
                    builder.add_jumped(x);
                }
                if let Some(x) = args.boostAmount {
                    builder.add_boostAmount(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.finish()
            }

            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_BOOSTAMOUNT: flatbuffers::VOffsetT = 6;
            pub const VT_JUMPED: flatbuffers::VOffsetT = 8;
            pub const VT_DOUBLEJUMPED: flatbuffers::VOffsetT = 10;

            #[inline]
            pub fn physics(&self) -> Option<DesiredPhysics<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DesiredPhysics<'a>>>(
                        DesiredCarState::VT_PHYSICS,
                        None,
                    )
            }
            #[inline]
            pub fn boostAmount(&self) -> Option<&'a Float> {
                self._tab
                    .get::<Float>(DesiredCarState::VT_BOOSTAMOUNT, None)
            }
            #[inline]
            pub fn jumped(&self) -> Option<&'a Bool> {
                self._tab.get::<Bool>(DesiredCarState::VT_JUMPED, None)
            }
            #[inline]
            pub fn doubleJumped(&self) -> Option<&'a Bool> {
                self._tab
                    .get::<Bool>(DesiredCarState::VT_DOUBLEJUMPED, None)
            }
        }

        pub struct DesiredCarStateArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<DesiredPhysics<'a>>>,
            pub boostAmount: Option<&'a Float>,
            pub jumped: Option<&'a Bool>,
            pub doubleJumped: Option<&'a Bool>,
        }
        impl<'a> Default for DesiredCarStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredCarStateArgs {
                    physics: None,
                    boostAmount: None,
                    jumped: None,
                    doubleJumped: None,
                }
            }
        }
        pub struct DesiredCarStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredCarStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<DesiredPhysics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredPhysics<'_>>>(
                        DesiredCarState::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_boostAmount(&mut self, boostAmount: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(DesiredCarState::VT_BOOSTAMOUNT, boostAmount);
            }
            #[inline]
            pub fn add_jumped(&mut self, jumped: &'b Bool) {
                self.fbb_
                    .push_slot_always::<&Bool>(DesiredCarState::VT_JUMPED, jumped);
            }
            #[inline]
            pub fn add_doubleJumped(&mut self, doubleJumped: &'b Bool) {
                self.fbb_
                    .push_slot_always::<&Bool>(DesiredCarState::VT_DOUBLEJUMPED, doubleJumped);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredCarStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredCarStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredCarState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredBoostStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredBoostState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredBoostState<'a> {
            type Inner = DesiredBoostState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredBoostState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredBoostState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredBoostStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredBoostState<'bldr>> {
                let mut builder = DesiredBoostStateBuilder::new(_fbb);
                if let Some(x) = args.respawnTime {
                    builder.add_respawnTime(x);
                }
                builder.finish()
            }

            pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn respawnTime(&self) -> Option<&'a Float> {
                self._tab
                    .get::<Float>(DesiredBoostState::VT_RESPAWNTIME, None)
            }
        }

        pub struct DesiredBoostStateArgs<'a> {
            pub respawnTime: Option<&'a Float>,
        }
        impl<'a> Default for DesiredBoostStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredBoostStateArgs { respawnTime: None }
            }
        }
        pub struct DesiredBoostStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredBoostStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_respawnTime(&mut self, respawnTime: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(DesiredBoostState::VT_RESPAWNTIME, respawnTime);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredBoostStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredBoostStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredBoostState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredGameInfoStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredGameInfoState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredGameInfoState<'a> {
            type Inner = DesiredGameInfoState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredGameInfoState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredGameInfoState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredGameInfoStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredGameInfoState<'bldr>> {
                let mut builder = DesiredGameInfoStateBuilder::new(_fbb);
                if let Some(x) = args.gameSpeed {
                    builder.add_gameSpeed(x);
                }
                if let Some(x) = args.worldGravityZ {
                    builder.add_worldGravityZ(x);
                }
                builder.finish()
            }

            pub const VT_WORLDGRAVITYZ: flatbuffers::VOffsetT = 4;
            pub const VT_GAMESPEED: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn worldGravityZ(&self) -> Option<&'a Float> {
                self._tab
                    .get::<Float>(DesiredGameInfoState::VT_WORLDGRAVITYZ, None)
            }
            #[inline]
            pub fn gameSpeed(&self) -> Option<&'a Float> {
                self._tab
                    .get::<Float>(DesiredGameInfoState::VT_GAMESPEED, None)
            }
        }

        pub struct DesiredGameInfoStateArgs<'a> {
            pub worldGravityZ: Option<&'a Float>,
            pub gameSpeed: Option<&'a Float>,
        }
        impl<'a> Default for DesiredGameInfoStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredGameInfoStateArgs {
                    worldGravityZ: None,
                    gameSpeed: None,
                }
            }
        }
        pub struct DesiredGameInfoStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredGameInfoStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_worldGravityZ(&mut self, worldGravityZ: &'b Float) {
                self.fbb_.push_slot_always::<&Float>(
                    DesiredGameInfoState::VT_WORLDGRAVITYZ,
                    worldGravityZ,
                );
            }
            #[inline]
            pub fn add_gameSpeed(&mut self, gameSpeed: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(DesiredGameInfoState::VT_GAMESPEED, gameSpeed);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredGameInfoStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredGameInfoStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredGameInfoState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A console command which we will try to execute inside Rocket League.
        /// See https://github.com/RLBot/RLBot/wiki/Console-Commands for a list of known commands.
        pub enum ConsoleCommandOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct ConsoleCommand<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ConsoleCommand<'a> {
            type Inner = ConsoleCommand<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> ConsoleCommand<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ConsoleCommand { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ConsoleCommandArgs<'args>,
            ) -> flatbuffers::WIPOffset<ConsoleCommand<'bldr>> {
                let mut builder = ConsoleCommandBuilder::new(_fbb);
                if let Some(x) = args.command {
                    builder.add_command(x);
                }
                builder.finish()
            }

            pub const VT_COMMAND: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn command(&self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ConsoleCommand::VT_COMMAND, None)
            }
        }

        pub struct ConsoleCommandArgs<'a> {
            pub command: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for ConsoleCommandArgs<'a> {
            #[inline]
            fn default() -> Self {
                ConsoleCommandArgs { command: None }
            }
        }
        pub struct ConsoleCommandBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ConsoleCommandBuilder<'a, 'b> {
            #[inline]
            pub fn add_command(&mut self, command: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ConsoleCommand::VT_COMMAND,
                    command,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ConsoleCommandBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ConsoleCommandBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ConsoleCommand<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredGameStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredGameState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredGameState<'a> {
            type Inner = DesiredGameState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredGameState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredGameState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredGameStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredGameState<'bldr>> {
                let mut builder = DesiredGameStateBuilder::new(_fbb);
                if let Some(x) = args.consoleCommands {
                    builder.add_consoleCommands(x);
                }
                if let Some(x) = args.gameInfoState {
                    builder.add_gameInfoState(x);
                }
                if let Some(x) = args.boostStates {
                    builder.add_boostStates(x);
                }
                if let Some(x) = args.carStates {
                    builder.add_carStates(x);
                }
                if let Some(x) = args.ballState {
                    builder.add_ballState(x);
                }
                builder.finish()
            }

            pub const VT_BALLSTATE: flatbuffers::VOffsetT = 4;
            pub const VT_CARSTATES: flatbuffers::VOffsetT = 6;
            pub const VT_BOOSTSTATES: flatbuffers::VOffsetT = 8;
            pub const VT_GAMEINFOSTATE: flatbuffers::VOffsetT = 10;
            pub const VT_CONSOLECOMMANDS: flatbuffers::VOffsetT = 12;

            #[inline]
            pub fn ballState(&self) -> Option<DesiredBallState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DesiredBallState<'a>>>(
                        DesiredGameState::VT_BALLSTATE,
                        None,
                    )
            }
            #[inline]
            pub fn carStates(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>,
                >>(DesiredGameState::VT_CARSTATES, None)
            }
            #[inline]
            pub fn boostStates(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>,
                >>(DesiredGameState::VT_BOOSTSTATES, None)
            }
            #[inline]
            pub fn gameInfoState(&self) -> Option<DesiredGameInfoState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DesiredGameInfoState<'a>>>(
                        DesiredGameState::VT_GAMEINFOSTATE,
                        None,
                    )
            }
            #[inline]
            pub fn consoleCommands(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ConsoleCommand<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ConsoleCommand<'a>>>,
                >>(DesiredGameState::VT_CONSOLECOMMANDS, None)
            }
        }

        pub struct DesiredGameStateArgs<'a> {
            pub ballState: Option<flatbuffers::WIPOffset<DesiredBallState<'a>>>,
            pub carStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>,
                >,
            >,
            pub boostStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>,
                >,
            >,
            pub gameInfoState: Option<flatbuffers::WIPOffset<DesiredGameInfoState<'a>>>,
            pub consoleCommands: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleCommand<'a>>>,
                >,
            >,
        }
        impl<'a> Default for DesiredGameStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredGameStateArgs {
                    ballState: None,
                    carStates: None,
                    boostStates: None,
                    gameInfoState: None,
                    consoleCommands: None,
                }
            }
        }
        pub struct DesiredGameStateBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredGameStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_ballState(
                &mut self,
                ballState: flatbuffers::WIPOffset<DesiredBallState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredBallState<'_>>>(
                        DesiredGameState::VT_BALLSTATE,
                        ballState,
                    );
            }
            #[inline]
            pub fn add_carStates(
                &mut self,
                carStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DesiredCarState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DesiredGameState::VT_CARSTATES,
                    carStates,
                );
            }
            #[inline]
            pub fn add_boostStates(
                &mut self,
                boostStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DesiredBoostState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DesiredGameState::VT_BOOSTSTATES,
                    boostStates,
                );
            }
            #[inline]
            pub fn add_gameInfoState(
                &mut self,
                gameInfoState: flatbuffers::WIPOffset<DesiredGameInfoState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredGameInfoState<'_>>>(
                        DesiredGameState::VT_GAMEINFOSTATE,
                        gameInfoState,
                    );
            }
            #[inline]
            pub fn add_consoleCommands(
                &mut self,
                consoleCommands: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ConsoleCommand<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DesiredGameState::VT_CONSOLECOMMANDS,
                    consoleCommands,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredGameStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredGameStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredGameState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum ColorOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Color<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Color<'a> {
            type Inner = Color<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> Color<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Color { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ColorArgs,
            ) -> flatbuffers::WIPOffset<Color<'bldr>> {
                let mut builder = ColorBuilder::new(_fbb);
                builder.add_b(args.b);
                builder.add_g(args.g);
                builder.add_r(args.r);
                builder.add_a(args.a);
                builder.finish()
            }

            pub const VT_A: flatbuffers::VOffsetT = 4;
            pub const VT_R: flatbuffers::VOffsetT = 6;
            pub const VT_G: flatbuffers::VOffsetT = 8;
            pub const VT_B: flatbuffers::VOffsetT = 10;

            #[inline]
            pub fn a(&self) -> u8 {
                self._tab.get::<u8>(Color::VT_A, Some(0)).unwrap()
            }
            #[inline]
            pub fn r(&self) -> u8 {
                self._tab.get::<u8>(Color::VT_R, Some(0)).unwrap()
            }
            #[inline]
            pub fn g(&self) -> u8 {
                self._tab.get::<u8>(Color::VT_G, Some(0)).unwrap()
            }
            #[inline]
            pub fn b(&self) -> u8 {
                self._tab.get::<u8>(Color::VT_B, Some(0)).unwrap()
            }
        }

        pub struct ColorArgs {
            pub a: u8,
            pub r: u8,
            pub g: u8,
            pub b: u8,
        }
        impl<'a> Default for ColorArgs {
            #[inline]
            fn default() -> Self {
                ColorArgs {
                    a: 0,
                    r: 0,
                    g: 0,
                    b: 0,
                }
            }
        }
        pub struct ColorBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ColorBuilder<'a, 'b> {
            #[inline]
            pub fn add_a(&mut self, a: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_A, a, 0);
            }
            #[inline]
            pub fn add_r(&mut self, r: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_R, r, 0);
            }
            #[inline]
            pub fn add_g(&mut self, g: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_G, g, 0);
            }
            #[inline]
            pub fn add_b(&mut self, b: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_B, b, 0);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColorBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ColorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Color<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum RenderMessageOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RenderMessage<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RenderMessage<'a> {
            type Inner = RenderMessage<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RenderMessage<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RenderMessage { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RenderMessageArgs<'args>,
            ) -> flatbuffers::WIPOffset<RenderMessage<'bldr>> {
                let mut builder = RenderMessageBuilder::new(_fbb);
                if let Some(x) = args.text {
                    builder.add_text(x);
                }
                builder.add_scaleY(args.scaleY);
                builder.add_scaleX(args.scaleX);
                if let Some(x) = args.end {
                    builder.add_end(x);
                }
                if let Some(x) = args.start {
                    builder.add_start(x);
                }
                if let Some(x) = args.color {
                    builder.add_color(x);
                }
                builder.add_isFilled(args.isFilled);
                builder.add_renderType(args.renderType);
                builder.finish()
            }

            pub const VT_RENDERTYPE: flatbuffers::VOffsetT = 4;
            pub const VT_COLOR: flatbuffers::VOffsetT = 6;
            pub const VT_START: flatbuffers::VOffsetT = 8;
            pub const VT_END: flatbuffers::VOffsetT = 10;
            pub const VT_SCALEX: flatbuffers::VOffsetT = 12;
            pub const VT_SCALEY: flatbuffers::VOffsetT = 14;
            pub const VT_TEXT: flatbuffers::VOffsetT = 16;
            pub const VT_ISFILLED: flatbuffers::VOffsetT = 18;

            #[inline]
            pub fn renderType(&self) -> RenderType {
                self._tab
                    .get::<RenderType>(RenderMessage::VT_RENDERTYPE, Some(RenderType::DrawLine2D))
                    .unwrap()
            }
            #[inline]
            pub fn color(&self) -> Option<Color<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Color<'a>>>(RenderMessage::VT_COLOR, None)
            }
            /// For 2d renders this only grabs x and y
            #[inline]
            pub fn start(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(RenderMessage::VT_START, None)
            }
            /// For 2d renders this only grabs x and y
            #[inline]
            pub fn end(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(RenderMessage::VT_END, None)
            }
            /// Scales the x size of the text/rectangle, is used for rectangles
            /// assuming an initial value of 1
            #[inline]
            pub fn scaleX(&self) -> i32 {
                self._tab
                    .get::<i32>(RenderMessage::VT_SCALEX, Some(1))
                    .unwrap()
            }
            /// Scales the y size of the text/rectangle, is used for rectangles
            /// assuming an initial value of 1
            #[inline]
            pub fn scaleY(&self) -> i32 {
                self._tab
                    .get::<i32>(RenderMessage::VT_SCALEY, Some(1))
                    .unwrap()
            }
            #[inline]
            pub fn text(&self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(RenderMessage::VT_TEXT, None)
            }
            /// Rectangles can be filled or just outlines.
            #[inline]
            pub fn isFilled(&self) -> bool {
                self._tab
                    .get::<bool>(RenderMessage::VT_ISFILLED, Some(false))
                    .unwrap()
            }
        }

        pub struct RenderMessageArgs<'a> {
            pub renderType: RenderType,
            pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
            pub start: Option<&'a Vector3>,
            pub end: Option<&'a Vector3>,
            pub scaleX: i32,
            pub scaleY: i32,
            pub text: Option<flatbuffers::WIPOffset<&'a str>>,
            pub isFilled: bool,
        }
        impl<'a> Default for RenderMessageArgs<'a> {
            #[inline]
            fn default() -> Self {
                RenderMessageArgs {
                    renderType: RenderType::DrawLine2D,
                    color: None,
                    start: None,
                    end: None,
                    scaleX: 1,
                    scaleY: 1,
                    text: None,
                    isFilled: false,
                }
            }
        }
        pub struct RenderMessageBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RenderMessageBuilder<'a, 'b> {
            #[inline]
            pub fn add_renderType(&mut self, renderType: RenderType) {
                self.fbb_.push_slot::<RenderType>(
                    RenderMessage::VT_RENDERTYPE,
                    renderType,
                    RenderType::DrawLine2D,
                );
            }
            #[inline]
            pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Color<'_>>>(
                        RenderMessage::VT_COLOR,
                        color,
                    );
            }
            #[inline]
            pub fn add_start(&mut self, start: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RenderMessage::VT_START, start);
            }
            #[inline]
            pub fn add_end(&mut self, end: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RenderMessage::VT_END, end);
            }
            #[inline]
            pub fn add_scaleX(&mut self, scaleX: i32) {
                self.fbb_
                    .push_slot::<i32>(RenderMessage::VT_SCALEX, scaleX, 1);
            }
            #[inline]
            pub fn add_scaleY(&mut self, scaleY: i32) {
                self.fbb_
                    .push_slot::<i32>(RenderMessage::VT_SCALEY, scaleY, 1);
            }
            #[inline]
            pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(RenderMessage::VT_TEXT, text);
            }
            #[inline]
            pub fn add_isFilled(&mut self, isFilled: bool) {
                self.fbb_
                    .push_slot::<bool>(RenderMessage::VT_ISFILLED, isFilled, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RenderMessageBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RenderMessageBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RenderMessage<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum RenderGroupOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RenderGroup<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RenderGroup<'a> {
            type Inner = RenderGroup<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RenderGroup<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RenderGroup { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RenderGroupArgs<'args>,
            ) -> flatbuffers::WIPOffset<RenderGroup<'bldr>> {
                let mut builder = RenderGroupBuilder::new(_fbb);
                builder.add_id(args.id);
                if let Some(x) = args.renderMessages {
                    builder.add_renderMessages(x);
                }
                builder.finish()
            }

            pub const VT_RENDERMESSAGES: flatbuffers::VOffsetT = 4;
            pub const VT_ID: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn renderMessages(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RenderMessage<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RenderMessage<'a>>>,
                >>(RenderGroup::VT_RENDERMESSAGES, None)
            }
            /// The id of the render group
            #[inline]
            pub fn id(&self) -> i32 {
                self._tab.get::<i32>(RenderGroup::VT_ID, Some(0)).unwrap()
            }
        }

        pub struct RenderGroupArgs<'a> {
            pub renderMessages: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RenderMessage<'a>>>,
                >,
            >,
            pub id: i32,
        }
        impl<'a> Default for RenderGroupArgs<'a> {
            #[inline]
            fn default() -> Self {
                RenderGroupArgs {
                    renderMessages: None,
                    id: 0,
                }
            }
        }
        pub struct RenderGroupBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RenderGroupBuilder<'a, 'b> {
            #[inline]
            pub fn add_renderMessages(
                &mut self,
                renderMessages: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RenderMessage<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    RenderGroup::VT_RENDERMESSAGES,
                    renderMessages,
                );
            }
            #[inline]
            pub fn add_id(&mut self, id: i32) {
                self.fbb_.push_slot::<i32>(RenderGroup::VT_ID, id, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RenderGroupBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RenderGroupBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RenderGroup<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum QuickChatOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct QuickChat<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for QuickChat<'a> {
            type Inner = QuickChat<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> QuickChat<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                QuickChat { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args QuickChatArgs,
            ) -> flatbuffers::WIPOffset<QuickChat<'bldr>> {
                let mut builder = QuickChatBuilder::new(_fbb);
                builder.add_timeStamp(args.timeStamp);
                builder.add_messageIndex(args.messageIndex);
                builder.add_playerIndex(args.playerIndex);
                builder.add_teamOnly(args.teamOnly);
                builder.add_quickChatSelection(args.quickChatSelection);
                builder.finish()
            }

            pub const VT_QUICKCHATSELECTION: flatbuffers::VOffsetT = 4;
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 6;
            pub const VT_TEAMONLY: flatbuffers::VOffsetT = 8;
            pub const VT_MESSAGEINDEX: flatbuffers::VOffsetT = 10;
            pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

            #[inline]
            pub fn quickChatSelection(&self) -> QuickChatSelection {
                self._tab
                    .get::<QuickChatSelection>(
                        QuickChat::VT_QUICKCHATSELECTION,
                        Some(QuickChatSelection::Information_IGotIt),
                    )
                    .unwrap()
            }
            /// The index of the player that sent the quick chat
            #[inline]
            pub fn playerIndex(&self) -> i32 {
                self._tab
                    .get::<i32>(QuickChat::VT_PLAYERINDEX, Some(0))
                    .unwrap()
            }
            /// True if the chat is team only false if everyone can see it.
            #[inline]
            pub fn teamOnly(&self) -> bool {
                self._tab
                    .get::<bool>(QuickChat::VT_TEAMONLY, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn messageIndex(&self) -> i32 {
                self._tab
                    .get::<i32>(QuickChat::VT_MESSAGEINDEX, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn timeStamp(&self) -> f32 {
                self._tab
                    .get::<f32>(QuickChat::VT_TIMESTAMP, Some(0.0))
                    .unwrap()
            }
        }

        pub struct QuickChatArgs {
            pub quickChatSelection: QuickChatSelection,
            pub playerIndex: i32,
            pub teamOnly: bool,
            pub messageIndex: i32,
            pub timeStamp: f32,
        }
        impl<'a> Default for QuickChatArgs {
            #[inline]
            fn default() -> Self {
                QuickChatArgs {
                    quickChatSelection: QuickChatSelection::Information_IGotIt,
                    playerIndex: 0,
                    teamOnly: false,
                    messageIndex: 0,
                    timeStamp: 0.0,
                }
            }
        }
        pub struct QuickChatBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> QuickChatBuilder<'a, 'b> {
            #[inline]
            pub fn add_quickChatSelection(&mut self, quickChatSelection: QuickChatSelection) {
                self.fbb_.push_slot::<QuickChatSelection>(
                    QuickChat::VT_QUICKCHATSELECTION,
                    quickChatSelection,
                    QuickChatSelection::Information_IGotIt,
                );
            }
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(QuickChat::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn add_teamOnly(&mut self, teamOnly: bool) {
                self.fbb_
                    .push_slot::<bool>(QuickChat::VT_TEAMONLY, teamOnly, false);
            }
            #[inline]
            pub fn add_messageIndex(&mut self, messageIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(QuickChat::VT_MESSAGEINDEX, messageIndex, 0);
            }
            #[inline]
            pub fn add_timeStamp(&mut self, timeStamp: f32) {
                self.fbb_
                    .push_slot::<f32>(QuickChat::VT_TIMESTAMP, timeStamp, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> QuickChatBuilder<'a, 'b> {
                let start = _fbb.start_table();
                QuickChatBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<QuickChat<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A minimal version of player data, useful when bandwidth needs to be
        /// conserved.
        pub enum TinyPlayerOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct TinyPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyPlayer<'a> {
            type Inner = TinyPlayer<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> TinyPlayer<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyPlayerArgs<'args>,
            ) -> flatbuffers::WIPOffset<TinyPlayer<'bldr>> {
                let mut builder = TinyPlayerBuilder::new(_fbb);
                builder.add_boost(args.boost);
                builder.add_team(args.team);
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_isSupersonic(args.isSupersonic);
                builder.add_hasWheelContact(args.hasWheelContact);
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_HASWHEELCONTACT: flatbuffers::VOffsetT = 10;
            pub const VT_ISSUPERSONIC: flatbuffers::VOffsetT = 12;
            pub const VT_TEAM: flatbuffers::VOffsetT = 14;
            pub const VT_BOOST: flatbuffers::VOffsetT = 16;

            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(TinyPlayer::VT_LOCATION, None)
            }
            #[inline]
            pub fn rotation(&self) -> Option<&'a Rotator> {
                self._tab.get::<Rotator>(TinyPlayer::VT_ROTATION, None)
            }
            #[inline]
            pub fn velocity(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(TinyPlayer::VT_VELOCITY, None)
            }
            #[inline]
            pub fn hasWheelContact(&self) -> bool {
                self._tab
                    .get::<bool>(TinyPlayer::VT_HASWHEELCONTACT, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn isSupersonic(&self) -> bool {
                self._tab
                    .get::<bool>(TinyPlayer::VT_ISSUPERSONIC, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn team(&self) -> i32 {
                self._tab.get::<i32>(TinyPlayer::VT_TEAM, Some(0)).unwrap()
            }
            #[inline]
            pub fn boost(&self) -> i32 {
                self._tab.get::<i32>(TinyPlayer::VT_BOOST, Some(0)).unwrap()
            }
        }

        pub struct TinyPlayerArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub rotation: Option<&'a Rotator>,
            pub velocity: Option<&'a Vector3>,
            pub hasWheelContact: bool,
            pub isSupersonic: bool,
            pub team: i32,
            pub boost: i32,
        }
        impl<'a> Default for TinyPlayerArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyPlayerArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    hasWheelContact: false,
                    isSupersonic: false,
                    team: 0,
                    boost: 0,
                }
            }
        }
        pub struct TinyPlayerBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyPlayer::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: &'b Rotator) {
                self.fbb_
                    .push_slot_always::<&Rotator>(TinyPlayer::VT_ROTATION, rotation);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyPlayer::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn add_hasWheelContact(&mut self, hasWheelContact: bool) {
                self.fbb_
                    .push_slot::<bool>(TinyPlayer::VT_HASWHEELCONTACT, hasWheelContact, false);
            }
            #[inline]
            pub fn add_isSupersonic(&mut self, isSupersonic: bool) {
                self.fbb_
                    .push_slot::<bool>(TinyPlayer::VT_ISSUPERSONIC, isSupersonic, false);
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_.push_slot::<i32>(TinyPlayer::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: i32) {
                self.fbb_.push_slot::<i32>(TinyPlayer::VT_BOOST, boost, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A minimal version of the ball, useful when bandwidth needs to be
        /// conserved.
        pub enum TinyBallOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct TinyBall<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyBall<'a> {
            type Inner = TinyBall<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> TinyBall<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyBall { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyBallArgs<'args>,
            ) -> flatbuffers::WIPOffset<TinyBall<'bldr>> {
                let mut builder = TinyBallBuilder::new(_fbb);
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(TinyBall::VT_LOCATION, None)
            }
            #[inline]
            pub fn velocity(&self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(TinyBall::VT_VELOCITY, None)
            }
        }

        pub struct TinyBallArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub velocity: Option<&'a Vector3>,
        }
        impl<'a> Default for TinyBallArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyBallArgs {
                    location: None,
                    velocity: None,
                }
            }
        }
        pub struct TinyBallBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyBallBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyBall::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyBall::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyBallBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyBallBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyBall<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A minimal version of the game tick packet, useful when bandwidth
        /// needs to be conserved.
        pub enum TinyPacketOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct TinyPacket<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyPacket<'a> {
            type Inner = TinyPacket<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> TinyPacket<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyPacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyPacketArgs<'args>,
            ) -> flatbuffers::WIPOffset<TinyPacket<'bldr>> {
                let mut builder = TinyPacketBuilder::new(_fbb);
                if let Some(x) = args.ball {
                    builder.add_ball(x);
                }
                if let Some(x) = args.players {
                    builder.add_players(x);
                }
                builder.finish()
            }

            pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;
            pub const VT_BALL: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn players(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>,
                >>(TinyPacket::VT_PLAYERS, None)
            }
            #[inline]
            pub fn ball(&self) -> Option<TinyBall<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<TinyBall<'a>>>(TinyPacket::VT_BALL, None)
            }
        }

        pub struct TinyPacketArgs<'a> {
            pub players: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>,
                >,
            >,
            pub ball: Option<flatbuffers::WIPOffset<TinyBall<'a>>>,
        }
        impl<'a> Default for TinyPacketArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyPacketArgs {
                    players: None,
                    ball: None,
                }
            }
        }
        pub struct TinyPacketBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyPacketBuilder<'a, 'b> {
            #[inline]
            pub fn add_players(
                &mut self,
                players: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TinyPlayer<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TinyPacket::VT_PLAYERS, players);
            }
            #[inline]
            pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<TinyBall<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TinyBall<'_>>>(
                        TinyPacket::VT_BALL,
                        ball,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyPacketBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyPacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyPacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PredictionSliceOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PredictionSlice<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PredictionSlice<'a> {
            type Inner = PredictionSlice<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PredictionSlice<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PredictionSlice { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PredictionSliceArgs<'args>,
            ) -> flatbuffers::WIPOffset<PredictionSlice<'bldr>> {
                let mut builder = PredictionSliceBuilder::new(_fbb);
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.add_gameSeconds(args.gameSeconds);
                builder.finish()
            }

            pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 4;
            pub const VT_PHYSICS: flatbuffers::VOffsetT = 6;

            /// The moment in game time that this prediction corresponds to.
            /// This corresponds to 'secondsElapsed' in the GameInfo table.
            #[inline]
            pub fn gameSeconds(&self) -> f32 {
                self._tab
                    .get::<f32>(PredictionSlice::VT_GAMESECONDS, Some(0.0))
                    .unwrap()
            }
            /// The predicted location and motion of the object.
            #[inline]
            pub fn physics(&self) -> Option<Physics<'a>> {
                self._tab.get::<flatbuffers::ForwardsUOffset<Physics<'a>>>(
                    PredictionSlice::VT_PHYSICS,
                    None,
                )
            }
        }

        pub struct PredictionSliceArgs<'a> {
            pub gameSeconds: f32,
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
        }
        impl<'a> Default for PredictionSliceArgs<'a> {
            #[inline]
            fn default() -> Self {
                PredictionSliceArgs {
                    gameSeconds: 0.0,
                    physics: None,
                }
            }
        }
        pub struct PredictionSliceBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PredictionSliceBuilder<'a, 'b> {
            #[inline]
            pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
                self.fbb_
                    .push_slot::<f32>(PredictionSlice::VT_GAMESECONDS, gameSeconds, 0.0);
            }
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics<'_>>>(
                        PredictionSlice::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PredictionSliceBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PredictionSliceBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PredictionSlice<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BallPredictionOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BallPrediction<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BallPrediction<'a> {
            type Inner = BallPrediction<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BallPrediction<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BallPrediction { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BallPredictionArgs<'args>,
            ) -> flatbuffers::WIPOffset<BallPrediction<'bldr>> {
                let mut builder = BallPredictionBuilder::new(_fbb);
                if let Some(x) = args.slices {
                    builder.add_slices(x);
                }
                builder.finish()
            }

            pub const VT_SLICES: flatbuffers::VOffsetT = 4;

            /// A list of places the ball will be at specific times in the
            /// future. It is guaranteed to sorted so that time
            /// increases with each slice. It is NOT guaranteed to
            /// have a consistent amount of time between slices.
            #[inline]
            pub fn slices(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>,
                >>(BallPrediction::VT_SLICES, None)
            }
        }

        pub struct BallPredictionArgs<'a> {
            pub slices: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>,
                >,
            >,
        }
        impl<'a> Default for BallPredictionArgs<'a> {
            #[inline]
            fn default() -> Self {
                BallPredictionArgs { slices: None }
            }
        }
        pub struct BallPredictionBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BallPredictionBuilder<'a, 'b> {
            #[inline]
            pub fn add_slices(
                &mut self,
                slices: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PredictionSlice<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    BallPrediction::VT_SLICES,
                    slices,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BallPredictionBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BallPredictionBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BallPrediction<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A bot controlled by the RLBot framework
        pub enum RLBotPlayerOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RLBotPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RLBotPlayer<'a> {
            type Inner = RLBotPlayer<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RLBotPlayer<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RLBotPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                _args: &'args RLBotPlayerArgs,
            ) -> flatbuffers::WIPOffset<RLBotPlayer<'bldr>> {
                let mut builder = RLBotPlayerBuilder::new(_fbb);
                builder.finish()
            }
        }

        pub struct RLBotPlayerArgs {}
        impl<'a> Default for RLBotPlayerArgs {
            #[inline]
            fn default() -> Self {
                RLBotPlayerArgs {}
            }
        }
        pub struct RLBotPlayerBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RLBotPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RLBotPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RLBotPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RLBotPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A normal human player
        pub enum HumanPlayerOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct HumanPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for HumanPlayer<'a> {
            type Inner = HumanPlayer<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> HumanPlayer<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                HumanPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                _args: &'args HumanPlayerArgs,
            ) -> flatbuffers::WIPOffset<HumanPlayer<'bldr>> {
                let mut builder = HumanPlayerBuilder::new(_fbb);
                builder.finish()
            }
        }

        pub struct HumanPlayerArgs {}
        impl<'a> Default for HumanPlayerArgs {
            #[inline]
            fn default() -> Self {
                HumanPlayerArgs {}
            }
        }
        pub struct HumanPlayerBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> HumanPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> HumanPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                HumanPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<HumanPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A psyonix bot, e.g. All Star bot
        pub enum PsyonixBotPlayerOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PsyonixBotPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PsyonixBotPlayer<'a> {
            type Inner = PsyonixBotPlayer<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PsyonixBotPlayer<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PsyonixBotPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PsyonixBotPlayerArgs,
            ) -> flatbuffers::WIPOffset<PsyonixBotPlayer<'bldr>> {
                let mut builder = PsyonixBotPlayerBuilder::new(_fbb);
                builder.add_botSkill(args.botSkill);
                builder.finish()
            }

            pub const VT_BOTSKILL: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn botSkill(&self) -> f32 {
                self._tab
                    .get::<f32>(PsyonixBotPlayer::VT_BOTSKILL, Some(0.0))
                    .unwrap()
            }
        }

        pub struct PsyonixBotPlayerArgs {
            pub botSkill: f32,
        }
        impl<'a> Default for PsyonixBotPlayerArgs {
            #[inline]
            fn default() -> Self {
                PsyonixBotPlayerArgs { botSkill: 0.0 }
            }
        }
        pub struct PsyonixBotPlayerBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PsyonixBotPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn add_botSkill(&mut self, botSkill: f32) {
                self.fbb_
                    .push_slot::<f32>(PsyonixBotPlayer::VT_BOTSKILL, botSkill, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PsyonixBotPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PsyonixBotPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PsyonixBotPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A player that Rocket League treats as human, e.g. has a dedicated
        /// camera and can do training mode, but is actually controlled
        /// by a bot.
        pub enum PartyMemberBotPlayerOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PartyMemberBotPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PartyMemberBotPlayer<'a> {
            type Inner = PartyMemberBotPlayer<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PartyMemberBotPlayer<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PartyMemberBotPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                _args: &'args PartyMemberBotPlayerArgs,
            ) -> flatbuffers::WIPOffset<PartyMemberBotPlayer<'bldr>> {
                let mut builder = PartyMemberBotPlayerBuilder::new(_fbb);
                builder.finish()
            }
        }

        pub struct PartyMemberBotPlayerArgs {}
        impl<'a> Default for PartyMemberBotPlayerArgs {
            #[inline]
            fn default() -> Self {
                PartyMemberBotPlayerArgs {}
            }
        }
        pub struct PartyMemberBotPlayerBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PartyMemberBotPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PartyMemberBotPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PartyMemberBotPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PartyMemberBotPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// The car type, color, and other aspects of the player's appearance.
        /// See https://github.com/RLBot/RLBot/wiki/Bot-Customization
        pub enum PlayerLoadoutOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PlayerLoadout<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerLoadout<'a> {
            type Inner = PlayerLoadout<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PlayerLoadout<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerLoadout { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerLoadoutArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerLoadout<'bldr>> {
                let mut builder = PlayerLoadoutBuilder::new(_fbb);
                if let Some(x) = args.loadoutPaint {
                    builder.add_loadoutPaint(x);
                }
                builder.add_goalExplosionId(args.goalExplosionId);
                builder.add_trailsId(args.trailsId);
                builder.add_engineAudioId(args.engineAudioId);
                builder.add_customFinishId(args.customFinishId);
                builder.add_paintFinishId(args.paintFinishId);
                builder.add_hatId(args.hatId);
                builder.add_antennaId(args.antennaId);
                builder.add_boostId(args.boostId);
                builder.add_wheelsId(args.wheelsId);
                builder.add_decalId(args.decalId);
                builder.add_carId(args.carId);
                builder.add_customColorId(args.customColorId);
                builder.add_teamColorId(args.teamColorId);
                builder.finish()
            }

            pub const VT_TEAMCOLORID: flatbuffers::VOffsetT = 4;
            pub const VT_CUSTOMCOLORID: flatbuffers::VOffsetT = 6;
            pub const VT_CARID: flatbuffers::VOffsetT = 8;
            pub const VT_DECALID: flatbuffers::VOffsetT = 10;
            pub const VT_WHEELSID: flatbuffers::VOffsetT = 12;
            pub const VT_BOOSTID: flatbuffers::VOffsetT = 14;
            pub const VT_ANTENNAID: flatbuffers::VOffsetT = 16;
            pub const VT_HATID: flatbuffers::VOffsetT = 18;
            pub const VT_PAINTFINISHID: flatbuffers::VOffsetT = 20;
            pub const VT_CUSTOMFINISHID: flatbuffers::VOffsetT = 22;
            pub const VT_ENGINEAUDIOID: flatbuffers::VOffsetT = 24;
            pub const VT_TRAILSID: flatbuffers::VOffsetT = 26;
            pub const VT_GOALEXPLOSIONID: flatbuffers::VOffsetT = 28;
            pub const VT_LOADOUTPAINT: flatbuffers::VOffsetT = 30;

            #[inline]
            pub fn teamColorId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_TEAMCOLORID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn customColorId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_CUSTOMCOLORID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn carId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_CARID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn decalId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_DECALID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn wheelsId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_WHEELSID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn boostId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_BOOSTID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn antennaId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_ANTENNAID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn hatId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_HATID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn paintFinishId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_PAINTFINISHID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn customFinishId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_CUSTOMFINISHID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn engineAudioId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_ENGINEAUDIOID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn trailsId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_TRAILSID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn goalExplosionId(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerLoadout::VT_GOALEXPLOSIONID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn loadoutPaint(&self) -> Option<LoadoutPaint<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<LoadoutPaint<'a>>>(
                        PlayerLoadout::VT_LOADOUTPAINT,
                        None,
                    )
            }
        }

        pub struct PlayerLoadoutArgs<'a> {
            pub teamColorId: i32,
            pub customColorId: i32,
            pub carId: i32,
            pub decalId: i32,
            pub wheelsId: i32,
            pub boostId: i32,
            pub antennaId: i32,
            pub hatId: i32,
            pub paintFinishId: i32,
            pub customFinishId: i32,
            pub engineAudioId: i32,
            pub trailsId: i32,
            pub goalExplosionId: i32,
            pub loadoutPaint: Option<flatbuffers::WIPOffset<LoadoutPaint<'a>>>,
        }
        impl<'a> Default for PlayerLoadoutArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerLoadoutArgs {
                    teamColorId: 0,
                    customColorId: 0,
                    carId: 0,
                    decalId: 0,
                    wheelsId: 0,
                    boostId: 0,
                    antennaId: 0,
                    hatId: 0,
                    paintFinishId: 0,
                    customFinishId: 0,
                    engineAudioId: 0,
                    trailsId: 0,
                    goalExplosionId: 0,
                    loadoutPaint: None,
                }
            }
        }
        pub struct PlayerLoadoutBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerLoadoutBuilder<'a, 'b> {
            #[inline]
            pub fn add_teamColorId(&mut self, teamColorId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_TEAMCOLORID, teamColorId, 0);
            }
            #[inline]
            pub fn add_customColorId(&mut self, customColorId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_CUSTOMCOLORID, customColorId, 0);
            }
            #[inline]
            pub fn add_carId(&mut self, carId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_CARID, carId, 0);
            }
            #[inline]
            pub fn add_decalId(&mut self, decalId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_DECALID, decalId, 0);
            }
            #[inline]
            pub fn add_wheelsId(&mut self, wheelsId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_WHEELSID, wheelsId, 0);
            }
            #[inline]
            pub fn add_boostId(&mut self, boostId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_BOOSTID, boostId, 0);
            }
            #[inline]
            pub fn add_antennaId(&mut self, antennaId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_ANTENNAID, antennaId, 0);
            }
            #[inline]
            pub fn add_hatId(&mut self, hatId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_HATID, hatId, 0);
            }
            #[inline]
            pub fn add_paintFinishId(&mut self, paintFinishId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_PAINTFINISHID, paintFinishId, 0);
            }
            #[inline]
            pub fn add_customFinishId(&mut self, customFinishId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_CUSTOMFINISHID, customFinishId, 0);
            }
            #[inline]
            pub fn add_engineAudioId(&mut self, engineAudioId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_ENGINEAUDIOID, engineAudioId, 0);
            }
            #[inline]
            pub fn add_trailsId(&mut self, trailsId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_TRAILSID, trailsId, 0);
            }
            #[inline]
            pub fn add_goalExplosionId(&mut self, goalExplosionId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_GOALEXPLOSIONID, goalExplosionId, 0);
            }
            #[inline]
            pub fn add_loadoutPaint(
                &mut self,
                loadoutPaint: flatbuffers::WIPOffset<LoadoutPaint<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<LoadoutPaint<'_>>>(
                        PlayerLoadout::VT_LOADOUTPAINT,
                        loadoutPaint,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerLoadoutBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerLoadoutBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerLoadout<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// Specification for 'painted' items. See https://github.com/RLBot/RLBot/wiki/Bot-Customization
        pub enum LoadoutPaintOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct LoadoutPaint<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for LoadoutPaint<'a> {
            type Inner = LoadoutPaint<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> LoadoutPaint<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                LoadoutPaint { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args LoadoutPaintArgs,
            ) -> flatbuffers::WIPOffset<LoadoutPaint<'bldr>> {
                let mut builder = LoadoutPaintBuilder::new(_fbb);
                builder.add_goalExplosionPaintId(args.goalExplosionPaintId);
                builder.add_trailsPaintId(args.trailsPaintId);
                builder.add_hatPaintId(args.hatPaintId);
                builder.add_antennaPaintId(args.antennaPaintId);
                builder.add_boostPaintId(args.boostPaintId);
                builder.add_wheelsPaintId(args.wheelsPaintId);
                builder.add_decalPaintId(args.decalPaintId);
                builder.add_carPaintId(args.carPaintId);
                builder.finish()
            }

            pub const VT_CARPAINTID: flatbuffers::VOffsetT = 4;
            pub const VT_DECALPAINTID: flatbuffers::VOffsetT = 6;
            pub const VT_WHEELSPAINTID: flatbuffers::VOffsetT = 8;
            pub const VT_BOOSTPAINTID: flatbuffers::VOffsetT = 10;
            pub const VT_ANTENNAPAINTID: flatbuffers::VOffsetT = 12;
            pub const VT_HATPAINTID: flatbuffers::VOffsetT = 14;
            pub const VT_TRAILSPAINTID: flatbuffers::VOffsetT = 16;
            pub const VT_GOALEXPLOSIONPAINTID: flatbuffers::VOffsetT = 18;

            #[inline]
            pub fn carPaintId(&self) -> i32 {
                self._tab
                    .get::<i32>(LoadoutPaint::VT_CARPAINTID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn decalPaintId(&self) -> i32 {
                self._tab
                    .get::<i32>(LoadoutPaint::VT_DECALPAINTID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn wheelsPaintId(&self) -> i32 {
                self._tab
                    .get::<i32>(LoadoutPaint::VT_WHEELSPAINTID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn boostPaintId(&self) -> i32 {
                self._tab
                    .get::<i32>(LoadoutPaint::VT_BOOSTPAINTID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn antennaPaintId(&self) -> i32 {
                self._tab
                    .get::<i32>(LoadoutPaint::VT_ANTENNAPAINTID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn hatPaintId(&self) -> i32 {
                self._tab
                    .get::<i32>(LoadoutPaint::VT_HATPAINTID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn trailsPaintId(&self) -> i32 {
                self._tab
                    .get::<i32>(LoadoutPaint::VT_TRAILSPAINTID, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn goalExplosionPaintId(&self) -> i32 {
                self._tab
                    .get::<i32>(LoadoutPaint::VT_GOALEXPLOSIONPAINTID, Some(0))
                    .unwrap()
            }
        }

        pub struct LoadoutPaintArgs {
            pub carPaintId: i32,
            pub decalPaintId: i32,
            pub wheelsPaintId: i32,
            pub boostPaintId: i32,
            pub antennaPaintId: i32,
            pub hatPaintId: i32,
            pub trailsPaintId: i32,
            pub goalExplosionPaintId: i32,
        }
        impl<'a> Default for LoadoutPaintArgs {
            #[inline]
            fn default() -> Self {
                LoadoutPaintArgs {
                    carPaintId: 0,
                    decalPaintId: 0,
                    wheelsPaintId: 0,
                    boostPaintId: 0,
                    antennaPaintId: 0,
                    hatPaintId: 0,
                    trailsPaintId: 0,
                    goalExplosionPaintId: 0,
                }
            }
        }
        pub struct LoadoutPaintBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> LoadoutPaintBuilder<'a, 'b> {
            #[inline]
            pub fn add_carPaintId(&mut self, carPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_CARPAINTID, carPaintId, 0);
            }
            #[inline]
            pub fn add_decalPaintId(&mut self, decalPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_DECALPAINTID, decalPaintId, 0);
            }
            #[inline]
            pub fn add_wheelsPaintId(&mut self, wheelsPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_WHEELSPAINTID, wheelsPaintId, 0);
            }
            #[inline]
            pub fn add_boostPaintId(&mut self, boostPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_BOOSTPAINTID, boostPaintId, 0);
            }
            #[inline]
            pub fn add_antennaPaintId(&mut self, antennaPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_ANTENNAPAINTID, antennaPaintId, 0);
            }
            #[inline]
            pub fn add_hatPaintId(&mut self, hatPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_HATPAINTID, hatPaintId, 0);
            }
            #[inline]
            pub fn add_trailsPaintId(&mut self, trailsPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_TRAILSPAINTID, trailsPaintId, 0);
            }
            #[inline]
            pub fn add_goalExplosionPaintId(&mut self, goalExplosionPaintId: i32) {
                self.fbb_.push_slot::<i32>(
                    LoadoutPaint::VT_GOALEXPLOSIONPAINTID,
                    goalExplosionPaintId,
                    0,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> LoadoutPaintBuilder<'a, 'b> {
                let start = _fbb.start_table();
                LoadoutPaintBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<LoadoutPaint<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PlayerConfigurationOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PlayerConfiguration<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerConfiguration<'a> {
            type Inner = PlayerConfiguration<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PlayerConfiguration<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerConfiguration { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerConfigurationArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerConfiguration<'bldr>> {
                let mut builder = PlayerConfigurationBuilder::new(_fbb);
                if let Some(x) = args.loadout {
                    builder.add_loadout(x);
                }
                builder.add_team(args.team);
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                if let Some(x) = args.variety {
                    builder.add_variety(x);
                }
                builder.add_variety_type(args.variety_type);
                builder.finish()
            }

            pub const VT_VARIETY_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_VARIETY: flatbuffers::VOffsetT = 6;
            pub const VT_NAME: flatbuffers::VOffsetT = 8;
            pub const VT_TEAM: flatbuffers::VOffsetT = 10;
            pub const VT_LOADOUT: flatbuffers::VOffsetT = 12;

            #[inline]
            pub fn variety_type(&self) -> PlayerClass {
                self._tab
                    .get::<PlayerClass>(
                        PlayerConfiguration::VT_VARIETY_TYPE,
                        Some(PlayerClass::NONE),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn variety(&self) -> Option<flatbuffers::Table<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        PlayerConfiguration::VT_VARIETY,
                        None,
                    )
            }
            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PlayerConfiguration::VT_NAME, None)
            }
            #[inline]
            pub fn team(&self) -> i32 {
                self._tab
                    .get::<i32>(PlayerConfiguration::VT_TEAM, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn loadout(&self) -> Option<PlayerLoadout<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<PlayerLoadout<'a>>>(
                        PlayerConfiguration::VT_LOADOUT,
                        None,
                    )
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn variety_as_rlbot_player(&'a self) -> Option<RLBotPlayer<'_>> {
                if self.variety_type() == PlayerClass::RLBotPlayer {
                    self.variety().map(|u| RLBotPlayer::init_from_table(u))
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn variety_as_human_player(&'a self) -> Option<HumanPlayer<'_>> {
                if self.variety_type() == PlayerClass::HumanPlayer {
                    self.variety().map(|u| HumanPlayer::init_from_table(u))
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn variety_as_psyonix_bot_player(&'a self) -> Option<PsyonixBotPlayer<'_>> {
                if self.variety_type() == PlayerClass::PsyonixBotPlayer {
                    self.variety().map(|u| PsyonixBotPlayer::init_from_table(u))
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn variety_as_party_member_bot_player(
                &'a self,
            ) -> Option<PartyMemberBotPlayer<'_>> {
                if self.variety_type() == PlayerClass::PartyMemberBotPlayer {
                    self.variety()
                        .map(|u| PartyMemberBotPlayer::init_from_table(u))
                } else {
                    None
                }
            }
        }

        pub struct PlayerConfigurationArgs<'a> {
            pub variety_type: PlayerClass,
            pub variety: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub team: i32,
            pub loadout: Option<flatbuffers::WIPOffset<PlayerLoadout<'a>>>,
        }
        impl<'a> Default for PlayerConfigurationArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerConfigurationArgs {
                    variety_type: PlayerClass::NONE,
                    variety: None,
                    name: None,
                    team: 0,
                    loadout: None,
                }
            }
        }
        pub struct PlayerConfigurationBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerConfigurationBuilder<'a, 'b> {
            #[inline]
            pub fn add_variety_type(&mut self, variety_type: PlayerClass) {
                self.fbb_.push_slot::<PlayerClass>(
                    PlayerConfiguration::VT_VARIETY_TYPE,
                    variety_type,
                    PlayerClass::NONE,
                );
            }
            #[inline]
            pub fn add_variety(
                &mut self,
                variety: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    PlayerConfiguration::VT_VARIETY,
                    variety,
                );
            }
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    PlayerConfiguration::VT_NAME,
                    name,
                );
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerConfiguration::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_loadout(&mut self, loadout: flatbuffers::WIPOffset<PlayerLoadout<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<PlayerLoadout<'_>>>(
                        PlayerConfiguration::VT_LOADOUT,
                        loadout,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerConfigurationBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerConfigurationBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerConfiguration<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum MutatorSettingsOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct MutatorSettings<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MutatorSettings<'a> {
            type Inner = MutatorSettings<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> MutatorSettings<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MutatorSettings { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MutatorSettingsArgs,
            ) -> flatbuffers::WIPOffset<MutatorSettings<'bldr>> {
                let mut builder = MutatorSettingsBuilder::new(_fbb);
                builder.add_respawnTimeOption(args.respawnTimeOption);
                builder.add_demolishOption(args.demolishOption);
                builder.add_gravityOption(args.gravityOption);
                builder.add_boostStrengthOption(args.boostStrengthOption);
                builder.add_rumbleOption(args.rumbleOption);
                builder.add_boostOption(args.boostOption);
                builder.add_ballBouncinessOption(args.ballBouncinessOption);
                builder.add_ballSizeOption(args.ballSizeOption);
                builder.add_ballWeightOption(args.ballWeightOption);
                builder.add_ballTypeOption(args.ballTypeOption);
                builder.add_ballMaxSpeedOption(args.ballMaxSpeedOption);
                builder.add_gameSpeedOption(args.gameSpeedOption);
                builder.add_seriesLengthOption(args.seriesLengthOption);
                builder.add_overtimeOption(args.overtimeOption);
                builder.add_maxScore(args.maxScore);
                builder.add_matchLength(args.matchLength);
                builder.finish()
            }

            pub const VT_MATCHLENGTH: flatbuffers::VOffsetT = 4;
            pub const VT_MAXSCORE: flatbuffers::VOffsetT = 6;
            pub const VT_OVERTIMEOPTION: flatbuffers::VOffsetT = 8;
            pub const VT_SERIESLENGTHOPTION: flatbuffers::VOffsetT = 10;
            pub const VT_GAMESPEEDOPTION: flatbuffers::VOffsetT = 12;
            pub const VT_BALLMAXSPEEDOPTION: flatbuffers::VOffsetT = 14;
            pub const VT_BALLTYPEOPTION: flatbuffers::VOffsetT = 16;
            pub const VT_BALLWEIGHTOPTION: flatbuffers::VOffsetT = 18;
            pub const VT_BALLSIZEOPTION: flatbuffers::VOffsetT = 20;
            pub const VT_BALLBOUNCINESSOPTION: flatbuffers::VOffsetT = 22;
            pub const VT_BOOSTOPTION: flatbuffers::VOffsetT = 24;
            pub const VT_RUMBLEOPTION: flatbuffers::VOffsetT = 26;
            pub const VT_BOOSTSTRENGTHOPTION: flatbuffers::VOffsetT = 28;
            pub const VT_GRAVITYOPTION: flatbuffers::VOffsetT = 30;
            pub const VT_DEMOLISHOPTION: flatbuffers::VOffsetT = 32;
            pub const VT_RESPAWNTIMEOPTION: flatbuffers::VOffsetT = 34;

            #[inline]
            pub fn matchLength(&self) -> MatchLength {
                self._tab
                    .get::<MatchLength>(
                        MutatorSettings::VT_MATCHLENGTH,
                        Some(MatchLength::Five_Minutes),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn maxScore(&self) -> MaxScore {
                self._tab
                    .get::<MaxScore>(MutatorSettings::VT_MAXSCORE, Some(MaxScore::Unlimited))
                    .unwrap()
            }
            #[inline]
            pub fn overtimeOption(&self) -> OvertimeOption {
                self._tab
                    .get::<OvertimeOption>(
                        MutatorSettings::VT_OVERTIMEOPTION,
                        Some(OvertimeOption::Unlimited),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn seriesLengthOption(&self) -> SeriesLengthOption {
                self._tab
                    .get::<SeriesLengthOption>(
                        MutatorSettings::VT_SERIESLENGTHOPTION,
                        Some(SeriesLengthOption::Unlimited),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn gameSpeedOption(&self) -> GameSpeedOption {
                self._tab
                    .get::<GameSpeedOption>(
                        MutatorSettings::VT_GAMESPEEDOPTION,
                        Some(GameSpeedOption::Default),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn ballMaxSpeedOption(&self) -> BallMaxSpeedOption {
                self._tab
                    .get::<BallMaxSpeedOption>(
                        MutatorSettings::VT_BALLMAXSPEEDOPTION,
                        Some(BallMaxSpeedOption::Default),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn ballTypeOption(&self) -> BallTypeOption {
                self._tab
                    .get::<BallTypeOption>(
                        MutatorSettings::VT_BALLTYPEOPTION,
                        Some(BallTypeOption::Default),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn ballWeightOption(&self) -> BallWeightOption {
                self._tab
                    .get::<BallWeightOption>(
                        MutatorSettings::VT_BALLWEIGHTOPTION,
                        Some(BallWeightOption::Default),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn ballSizeOption(&self) -> BallSizeOption {
                self._tab
                    .get::<BallSizeOption>(
                        MutatorSettings::VT_BALLSIZEOPTION,
                        Some(BallSizeOption::Default),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn ballBouncinessOption(&self) -> BallBouncinessOption {
                self._tab
                    .get::<BallBouncinessOption>(
                        MutatorSettings::VT_BALLBOUNCINESSOPTION,
                        Some(BallBouncinessOption::Default),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn boostOption(&self) -> BoostOption {
                self._tab
                    .get::<BoostOption>(
                        MutatorSettings::VT_BOOSTOPTION,
                        Some(BoostOption::Normal_Boost),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn rumbleOption(&self) -> RumbleOption {
                self._tab
                    .get::<RumbleOption>(
                        MutatorSettings::VT_RUMBLEOPTION,
                        Some(RumbleOption::No_Rumble),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn boostStrengthOption(&self) -> BoostStrengthOption {
                self._tab
                    .get::<BoostStrengthOption>(
                        MutatorSettings::VT_BOOSTSTRENGTHOPTION,
                        Some(BoostStrengthOption::One),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn gravityOption(&self) -> GravityOption {
                self._tab
                    .get::<GravityOption>(
                        MutatorSettings::VT_GRAVITYOPTION,
                        Some(GravityOption::Default),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn demolishOption(&self) -> DemolishOption {
                self._tab
                    .get::<DemolishOption>(
                        MutatorSettings::VT_DEMOLISHOPTION,
                        Some(DemolishOption::Default),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn respawnTimeOption(&self) -> RespawnTimeOption {
                self._tab
                    .get::<RespawnTimeOption>(
                        MutatorSettings::VT_RESPAWNTIMEOPTION,
                        Some(RespawnTimeOption::Three_Seconds),
                    )
                    .unwrap()
            }
        }

        pub struct MutatorSettingsArgs {
            pub matchLength: MatchLength,
            pub maxScore: MaxScore,
            pub overtimeOption: OvertimeOption,
            pub seriesLengthOption: SeriesLengthOption,
            pub gameSpeedOption: GameSpeedOption,
            pub ballMaxSpeedOption: BallMaxSpeedOption,
            pub ballTypeOption: BallTypeOption,
            pub ballWeightOption: BallWeightOption,
            pub ballSizeOption: BallSizeOption,
            pub ballBouncinessOption: BallBouncinessOption,
            pub boostOption: BoostOption,
            pub rumbleOption: RumbleOption,
            pub boostStrengthOption: BoostStrengthOption,
            pub gravityOption: GravityOption,
            pub demolishOption: DemolishOption,
            pub respawnTimeOption: RespawnTimeOption,
        }
        impl<'a> Default for MutatorSettingsArgs {
            #[inline]
            fn default() -> Self {
                MutatorSettingsArgs {
                    matchLength: MatchLength::Five_Minutes,
                    maxScore: MaxScore::Unlimited,
                    overtimeOption: OvertimeOption::Unlimited,
                    seriesLengthOption: SeriesLengthOption::Unlimited,
                    gameSpeedOption: GameSpeedOption::Default,
                    ballMaxSpeedOption: BallMaxSpeedOption::Default,
                    ballTypeOption: BallTypeOption::Default,
                    ballWeightOption: BallWeightOption::Default,
                    ballSizeOption: BallSizeOption::Default,
                    ballBouncinessOption: BallBouncinessOption::Default,
                    boostOption: BoostOption::Normal_Boost,
                    rumbleOption: RumbleOption::No_Rumble,
                    boostStrengthOption: BoostStrengthOption::One,
                    gravityOption: GravityOption::Default,
                    demolishOption: DemolishOption::Default,
                    respawnTimeOption: RespawnTimeOption::Three_Seconds,
                }
            }
        }
        pub struct MutatorSettingsBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MutatorSettingsBuilder<'a, 'b> {
            #[inline]
            pub fn add_matchLength(&mut self, matchLength: MatchLength) {
                self.fbb_.push_slot::<MatchLength>(
                    MutatorSettings::VT_MATCHLENGTH,
                    matchLength,
                    MatchLength::Five_Minutes,
                );
            }
            #[inline]
            pub fn add_maxScore(&mut self, maxScore: MaxScore) {
                self.fbb_.push_slot::<MaxScore>(
                    MutatorSettings::VT_MAXSCORE,
                    maxScore,
                    MaxScore::Unlimited,
                );
            }
            #[inline]
            pub fn add_overtimeOption(&mut self, overtimeOption: OvertimeOption) {
                self.fbb_.push_slot::<OvertimeOption>(
                    MutatorSettings::VT_OVERTIMEOPTION,
                    overtimeOption,
                    OvertimeOption::Unlimited,
                );
            }
            #[inline]
            pub fn add_seriesLengthOption(&mut self, seriesLengthOption: SeriesLengthOption) {
                self.fbb_.push_slot::<SeriesLengthOption>(
                    MutatorSettings::VT_SERIESLENGTHOPTION,
                    seriesLengthOption,
                    SeriesLengthOption::Unlimited,
                );
            }
            #[inline]
            pub fn add_gameSpeedOption(&mut self, gameSpeedOption: GameSpeedOption) {
                self.fbb_.push_slot::<GameSpeedOption>(
                    MutatorSettings::VT_GAMESPEEDOPTION,
                    gameSpeedOption,
                    GameSpeedOption::Default,
                );
            }
            #[inline]
            pub fn add_ballMaxSpeedOption(&mut self, ballMaxSpeedOption: BallMaxSpeedOption) {
                self.fbb_.push_slot::<BallMaxSpeedOption>(
                    MutatorSettings::VT_BALLMAXSPEEDOPTION,
                    ballMaxSpeedOption,
                    BallMaxSpeedOption::Default,
                );
            }
            #[inline]
            pub fn add_ballTypeOption(&mut self, ballTypeOption: BallTypeOption) {
                self.fbb_.push_slot::<BallTypeOption>(
                    MutatorSettings::VT_BALLTYPEOPTION,
                    ballTypeOption,
                    BallTypeOption::Default,
                );
            }
            #[inline]
            pub fn add_ballWeightOption(&mut self, ballWeightOption: BallWeightOption) {
                self.fbb_.push_slot::<BallWeightOption>(
                    MutatorSettings::VT_BALLWEIGHTOPTION,
                    ballWeightOption,
                    BallWeightOption::Default,
                );
            }
            #[inline]
            pub fn add_ballSizeOption(&mut self, ballSizeOption: BallSizeOption) {
                self.fbb_.push_slot::<BallSizeOption>(
                    MutatorSettings::VT_BALLSIZEOPTION,
                    ballSizeOption,
                    BallSizeOption::Default,
                );
            }
            #[inline]
            pub fn add_ballBouncinessOption(&mut self, ballBouncinessOption: BallBouncinessOption) {
                self.fbb_.push_slot::<BallBouncinessOption>(
                    MutatorSettings::VT_BALLBOUNCINESSOPTION,
                    ballBouncinessOption,
                    BallBouncinessOption::Default,
                );
            }
            #[inline]
            pub fn add_boostOption(&mut self, boostOption: BoostOption) {
                self.fbb_.push_slot::<BoostOption>(
                    MutatorSettings::VT_BOOSTOPTION,
                    boostOption,
                    BoostOption::Normal_Boost,
                );
            }
            #[inline]
            pub fn add_rumbleOption(&mut self, rumbleOption: RumbleOption) {
                self.fbb_.push_slot::<RumbleOption>(
                    MutatorSettings::VT_RUMBLEOPTION,
                    rumbleOption,
                    RumbleOption::No_Rumble,
                );
            }
            #[inline]
            pub fn add_boostStrengthOption(&mut self, boostStrengthOption: BoostStrengthOption) {
                self.fbb_.push_slot::<BoostStrengthOption>(
                    MutatorSettings::VT_BOOSTSTRENGTHOPTION,
                    boostStrengthOption,
                    BoostStrengthOption::One,
                );
            }
            #[inline]
            pub fn add_gravityOption(&mut self, gravityOption: GravityOption) {
                self.fbb_.push_slot::<GravityOption>(
                    MutatorSettings::VT_GRAVITYOPTION,
                    gravityOption,
                    GravityOption::Default,
                );
            }
            #[inline]
            pub fn add_demolishOption(&mut self, demolishOption: DemolishOption) {
                self.fbb_.push_slot::<DemolishOption>(
                    MutatorSettings::VT_DEMOLISHOPTION,
                    demolishOption,
                    DemolishOption::Default,
                );
            }
            #[inline]
            pub fn add_respawnTimeOption(&mut self, respawnTimeOption: RespawnTimeOption) {
                self.fbb_.push_slot::<RespawnTimeOption>(
                    MutatorSettings::VT_RESPAWNTIMEOPTION,
                    respawnTimeOption,
                    RespawnTimeOption::Three_Seconds,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MutatorSettingsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MutatorSettingsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MutatorSettings<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum MatchSettingsOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct MatchSettings<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MatchSettings<'a> {
            type Inner = MatchSettings<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> MatchSettings<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MatchSettings { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MatchSettingsArgs<'args>,
            ) -> flatbuffers::WIPOffset<MatchSettings<'bldr>> {
                let mut builder = MatchSettingsBuilder::new(_fbb);
                if let Some(x) = args.mutatorSettings {
                    builder.add_mutatorSettings(x);
                }
                if let Some(x) = args.playerConfigurations {
                    builder.add_playerConfigurations(x);
                }
                builder.add_enableLockstep(args.enableLockstep);
                builder.add_existingMatchBehavior(args.existingMatchBehavior);
                builder.add_instantStart(args.instantStart);
                builder.add_skipReplays(args.skipReplays);
                builder.add_gameMap(args.gameMap);
                builder.add_gameMode(args.gameMode);
                builder.finish()
            }

            pub const VT_PLAYERCONFIGURATIONS: flatbuffers::VOffsetT = 4;
            pub const VT_GAMEMODE: flatbuffers::VOffsetT = 6;
            pub const VT_GAMEMAP: flatbuffers::VOffsetT = 8;
            pub const VT_SKIPREPLAYS: flatbuffers::VOffsetT = 10;
            pub const VT_INSTANTSTART: flatbuffers::VOffsetT = 12;
            pub const VT_MUTATORSETTINGS: flatbuffers::VOffsetT = 14;
            pub const VT_EXISTINGMATCHBEHAVIOR: flatbuffers::VOffsetT = 16;
            pub const VT_ENABLELOCKSTEP: flatbuffers::VOffsetT = 18;

            #[inline]
            pub fn playerConfigurations(
                &self,
            ) -> Option<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerConfiguration<'a>>>,
            > {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerConfiguration<'a>>>,
                >>(MatchSettings::VT_PLAYERCONFIGURATIONS, None)
            }
            #[inline]
            pub fn gameMode(&self) -> GameMode {
                self._tab
                    .get::<GameMode>(MatchSettings::VT_GAMEMODE, Some(GameMode::Soccer))
                    .unwrap()
            }
            #[inline]
            pub fn gameMap(&self) -> GameMap {
                self._tab
                    .get::<GameMap>(MatchSettings::VT_GAMEMAP, Some(GameMap::DFHStadium))
                    .unwrap()
            }
            #[inline]
            pub fn skipReplays(&self) -> bool {
                self._tab
                    .get::<bool>(MatchSettings::VT_SKIPREPLAYS, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn instantStart(&self) -> bool {
                self._tab
                    .get::<bool>(MatchSettings::VT_INSTANTSTART, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn mutatorSettings(&self) -> Option<MutatorSettings<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<MutatorSettings<'a>>>(
                        MatchSettings::VT_MUTATORSETTINGS,
                        None,
                    )
            }
            #[inline]
            pub fn existingMatchBehavior(&self) -> ExistingMatchBehavior {
                self._tab
                    .get::<ExistingMatchBehavior>(
                        MatchSettings::VT_EXISTINGMATCHBEHAVIOR,
                        Some(ExistingMatchBehavior::Restart_If_Different),
                    )
                    .unwrap()
            }
            #[inline]
            pub fn enableLockstep(&self) -> bool {
                self._tab
                    .get::<bool>(MatchSettings::VT_ENABLELOCKSTEP, Some(false))
                    .unwrap()
            }
        }

        pub struct MatchSettingsArgs<'a> {
            pub playerConfigurations: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerConfiguration<'a>>>,
                >,
            >,
            pub gameMode: GameMode,
            pub gameMap: GameMap,
            pub skipReplays: bool,
            pub instantStart: bool,
            pub mutatorSettings: Option<flatbuffers::WIPOffset<MutatorSettings<'a>>>,
            pub existingMatchBehavior: ExistingMatchBehavior,
            pub enableLockstep: bool,
        }
        impl<'a> Default for MatchSettingsArgs<'a> {
            #[inline]
            fn default() -> Self {
                MatchSettingsArgs {
                    playerConfigurations: None,
                    gameMode: GameMode::Soccer,
                    gameMap: GameMap::DFHStadium,
                    skipReplays: false,
                    instantStart: false,
                    mutatorSettings: None,
                    existingMatchBehavior: ExistingMatchBehavior::Restart_If_Different,
                    enableLockstep: false,
                }
            }
        }
        pub struct MatchSettingsBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MatchSettingsBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerConfigurations(
                &mut self,
                playerConfigurations: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlayerConfiguration<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MatchSettings::VT_PLAYERCONFIGURATIONS,
                    playerConfigurations,
                );
            }
            #[inline]
            pub fn add_gameMode(&mut self, gameMode: GameMode) {
                self.fbb_.push_slot::<GameMode>(
                    MatchSettings::VT_GAMEMODE,
                    gameMode,
                    GameMode::Soccer,
                );
            }
            #[inline]
            pub fn add_gameMap(&mut self, gameMap: GameMap) {
                self.fbb_.push_slot::<GameMap>(
                    MatchSettings::VT_GAMEMAP,
                    gameMap,
                    GameMap::DFHStadium,
                );
            }
            #[inline]
            pub fn add_skipReplays(&mut self, skipReplays: bool) {
                self.fbb_
                    .push_slot::<bool>(MatchSettings::VT_SKIPREPLAYS, skipReplays, false);
            }
            #[inline]
            pub fn add_instantStart(&mut self, instantStart: bool) {
                self.fbb_
                    .push_slot::<bool>(MatchSettings::VT_INSTANTSTART, instantStart, false);
            }
            #[inline]
            pub fn add_mutatorSettings(
                &mut self,
                mutatorSettings: flatbuffers::WIPOffset<MutatorSettings<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<MutatorSettings<'_>>>(
                        MatchSettings::VT_MUTATORSETTINGS,
                        mutatorSettings,
                    );
            }
            #[inline]
            pub fn add_existingMatchBehavior(
                &mut self,
                existingMatchBehavior: ExistingMatchBehavior,
            ) {
                self.fbb_.push_slot::<ExistingMatchBehavior>(
                    MatchSettings::VT_EXISTINGMATCHBEHAVIOR,
                    existingMatchBehavior,
                    ExistingMatchBehavior::Restart_If_Different,
                );
            }
            #[inline]
            pub fn add_enableLockstep(&mut self, enableLockstep: bool) {
                self.fbb_.push_slot::<bool>(
                    MatchSettings::VT_ENABLELOCKSTEP,
                    enableLockstep,
                    false,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MatchSettingsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MatchSettingsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MatchSettings<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum QuickChatMessagesOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct QuickChatMessages<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for QuickChatMessages<'a> {
            type Inner = QuickChatMessages<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> QuickChatMessages<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                QuickChatMessages { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args QuickChatMessagesArgs<'args>,
            ) -> flatbuffers::WIPOffset<QuickChatMessages<'bldr>> {
                let mut builder = QuickChatMessagesBuilder::new(_fbb);
                if let Some(x) = args.messages {
                    builder.add_messages(x);
                }
                builder.finish()
            }

            pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn messages(
                &self,
            ) -> Option<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<QuickChat<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<QuickChat<'a>>>,
                >>(QuickChatMessages::VT_MESSAGES, None)
            }
        }

        pub struct QuickChatMessagesArgs<'a> {
            pub messages: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QuickChat<'a>>>,
                >,
            >,
        }
        impl<'a> Default for QuickChatMessagesArgs<'a> {
            #[inline]
            fn default() -> Self {
                QuickChatMessagesArgs { messages: None }
            }
        }
        pub struct QuickChatMessagesBuilder<'a, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> QuickChatMessagesBuilder<'a, 'b> {
            #[inline]
            pub fn add_messages(
                &mut self,
                messages: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<QuickChat<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    QuickChatMessages::VT_MESSAGES,
                    messages,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> QuickChatMessagesBuilder<'a, 'b> {
                let start = _fbb.start_table();
                QuickChatMessagesBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<QuickChatMessages<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        #[inline]
        pub fn get_root_as_quick_chat<'a>(buf: &'a [u8]) -> QuickChat<'a> {
            flatbuffers::get_root::<QuickChat<'a>>(buf)
        }

        #[inline]
        pub fn get_size_prefixed_root_as_quick_chat<'a>(buf: &'a [u8]) -> QuickChat<'a> {
            flatbuffers::get_size_prefixed_root::<QuickChat<'a>>(buf)
        }

        #[inline]
        pub fn finish_quick_chat_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<QuickChat<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_quick_chat_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<QuickChat<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod flat
} // pub mod rlbot
