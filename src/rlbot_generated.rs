// automatically generated by the FlatBuffers compiler, do not modify

#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod rlbot {
    #![allow(non_camel_case_types, non_snake_case, missing_docs)]
    #![allow(dead_code)]
    #![allow(unused_imports)]

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;
    pub mod flat {
        #![allow(dead_code)]
        #![allow(unused_imports)]

        use std::cmp::Ordering;
        use std::mem;

        extern crate flatbuffers;
        use self::flatbuffers::EndianScalar;

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum TileState {
            Unknown = 0,
            /// The default state of the tiles.
            Filled = 1,
            /// The state when a tile has been damaged.
            Damaged = 2,
            /// The state of a tile when it is open and a goal can be scored.
            Open = 3,
        }

        const ENUM_MIN_TILE_STATE: i8 = 0;
        const ENUM_MAX_TILE_STATE: i8 = 3;

        impl<'a> flatbuffers::Follow<'a> for TileState {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for TileState {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const TileState;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const TileState;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for TileState {
            type Output = TileState;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<TileState>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_TILE_STATE: [TileState; 4] = [
            TileState::Unknown,
            TileState::Filled,
            TileState::Damaged,
            TileState::Open,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_TILE_STATE: [&'static str; 4] = ["Unknown", "Filled", "Damaged", "Open"];

        pub fn enum_name_tile_state(e: TileState) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_TILE_STATE[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum RenderType {
            DrawLine2D = 1,
            DrawLine3D = 2,
            DrawLine2D_3D = 3,
            DrawRect2D = 4,
            DrawRect3D = 5,
            DrawString2D = 6,
            DrawString3D = 7,
            DrawCenteredRect3D = 8,
        }

        const ENUM_MIN_RENDER_TYPE: i8 = 1;
        const ENUM_MAX_RENDER_TYPE: i8 = 8;

        impl<'a> flatbuffers::Follow<'a> for RenderType {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for RenderType {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const RenderType;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const RenderType;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for RenderType {
            type Output = RenderType;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<RenderType>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_RENDER_TYPE: [RenderType; 8] = [
            RenderType::DrawLine2D,
            RenderType::DrawLine3D,
            RenderType::DrawLine2D_3D,
            RenderType::DrawRect2D,
            RenderType::DrawRect3D,
            RenderType::DrawString2D,
            RenderType::DrawString3D,
            RenderType::DrawCenteredRect3D,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_RENDER_TYPE: [&'static str; 8] = [
            "DrawLine2D",
            "DrawLine3D",
            "DrawLine2D_3D",
            "DrawRect2D",
            "DrawRect3D",
            "DrawString2D",
            "DrawString3D",
            "DrawCenteredRect3D",
        ];

        pub fn enum_name_render_type(e: RenderType) -> &'static str {
            let index: usize = e as usize - RenderType::DrawLine2D as usize;
            ENUM_NAMES_RENDER_TYPE[index]
        }

        #[allow(non_camel_case_types)]
        #[repr(i8)]
        #[derive(Clone, Copy, PartialEq, Debug)]
        pub enum QuickChatSelection {
            Information_IGotIt = 0,
            Information_NeedBoost = 1,
            Information_TakeTheShot = 2,
            Information_Defending = 3,
            Information_GoForIt = 4,
            Information_Centering = 5,
            Information_AllYours = 6,
            Information_InPosition = 7,
            Information_Incoming = 8,
            Compliments_NiceShot = 9,
            Compliments_GreatPass = 10,
            Compliments_Thanks = 11,
            Compliments_WhatASave = 12,
            Compliments_NiceOne = 13,
            Compliments_WhatAPlay = 14,
            Compliments_GreatClear = 15,
            Compliments_NiceBlock = 16,
            Reactions_OMG = 17,
            Reactions_Noooo = 18,
            Reactions_Wow = 19,
            Reactions_CloseOne = 20,
            Reactions_NoWay = 21,
            Reactions_HolyCow = 22,
            Reactions_Whew = 23,
            Reactions_Siiiick = 24,
            Reactions_Calculated = 25,
            Reactions_Savage = 26,
            Reactions_Okay = 27,
            Apologies_Cursing = 28,
            Apologies_NoProblem = 29,
            Apologies_Whoops = 30,
            Apologies_Sorry = 31,
            Apologies_MyBad = 32,
            Apologies_Oops = 33,
            Apologies_MyFault = 34,
            PostGame_Gg = 35,
            PostGame_WellPlayed = 36,
            PostGame_ThatWasFun = 37,
            PostGame_Rematch = 38,
            PostGame_OneMoreGame = 39,
            PostGame_WhatAGame = 40,
            PostGame_NiceMoves = 41,
            PostGame_EverybodyDance = 42,

            MaxPysonixQuickChatPresets = 43,

            Custom_Toxic_WasteCPU = 44,

            Custom_Toxic_GitGut = 45,

            Custom_Toxic_DeAlloc = 46,

            Custom_Toxic_404NoSkill = 47,

            Custom_Toxic_CatchVirus = 48,

            Custom_Useful_Passing = 49,

            Custom_Useful_Faking = 50,

            Custom_Useful_Demoing = 51,

            Custom_Useful_Bumping = 52,

            Custom_Compliments_TinyChances = 53,

            Custom_Compliments_SkillLevel = 54,

            Custom_Compliments_proud = 55,

            Custom_Compliments_GC = 56,

            Custom_Compliments_Pro = 57,
        }

        const ENUM_MIN_QUICK_CHAT_SELECTION: i8 = 0;
        const ENUM_MAX_QUICK_CHAT_SELECTION: i8 = 57;

        impl<'a> flatbuffers::Follow<'a> for QuickChatSelection {
            type Inner = Self;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::read_scalar_at::<Self>(buf, loc)
            }
        }

        impl flatbuffers::EndianScalar for QuickChatSelection {
            #[inline]
            fn to_little_endian(self) -> Self {
                let n = i8::to_le(self as i8);
                let p = &n as *const i8 as *const QuickChatSelection;
                unsafe { *p }
            }
            #[inline]
            fn from_little_endian(self) -> Self {
                let n = i8::from_le(self as i8);
                let p = &n as *const i8 as *const QuickChatSelection;
                unsafe { *p }
            }
        }

        impl flatbuffers::Push for QuickChatSelection {
            type Output = QuickChatSelection;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                flatbuffers::emplace_scalar::<QuickChatSelection>(dst, *self);
            }
        }

        #[allow(non_camel_case_types)]
        const ENUM_VALUES_QUICK_CHAT_SELECTION: [QuickChatSelection; 58] = [
            QuickChatSelection::Information_IGotIt,
            QuickChatSelection::Information_NeedBoost,
            QuickChatSelection::Information_TakeTheShot,
            QuickChatSelection::Information_Defending,
            QuickChatSelection::Information_GoForIt,
            QuickChatSelection::Information_Centering,
            QuickChatSelection::Information_AllYours,
            QuickChatSelection::Information_InPosition,
            QuickChatSelection::Information_Incoming,
            QuickChatSelection::Compliments_NiceShot,
            QuickChatSelection::Compliments_GreatPass,
            QuickChatSelection::Compliments_Thanks,
            QuickChatSelection::Compliments_WhatASave,
            QuickChatSelection::Compliments_NiceOne,
            QuickChatSelection::Compliments_WhatAPlay,
            QuickChatSelection::Compliments_GreatClear,
            QuickChatSelection::Compliments_NiceBlock,
            QuickChatSelection::Reactions_OMG,
            QuickChatSelection::Reactions_Noooo,
            QuickChatSelection::Reactions_Wow,
            QuickChatSelection::Reactions_CloseOne,
            QuickChatSelection::Reactions_NoWay,
            QuickChatSelection::Reactions_HolyCow,
            QuickChatSelection::Reactions_Whew,
            QuickChatSelection::Reactions_Siiiick,
            QuickChatSelection::Reactions_Calculated,
            QuickChatSelection::Reactions_Savage,
            QuickChatSelection::Reactions_Okay,
            QuickChatSelection::Apologies_Cursing,
            QuickChatSelection::Apologies_NoProblem,
            QuickChatSelection::Apologies_Whoops,
            QuickChatSelection::Apologies_Sorry,
            QuickChatSelection::Apologies_MyBad,
            QuickChatSelection::Apologies_Oops,
            QuickChatSelection::Apologies_MyFault,
            QuickChatSelection::PostGame_Gg,
            QuickChatSelection::PostGame_WellPlayed,
            QuickChatSelection::PostGame_ThatWasFun,
            QuickChatSelection::PostGame_Rematch,
            QuickChatSelection::PostGame_OneMoreGame,
            QuickChatSelection::PostGame_WhatAGame,
            QuickChatSelection::PostGame_NiceMoves,
            QuickChatSelection::PostGame_EverybodyDance,
            QuickChatSelection::MaxPysonixQuickChatPresets,
            QuickChatSelection::Custom_Toxic_WasteCPU,
            QuickChatSelection::Custom_Toxic_GitGut,
            QuickChatSelection::Custom_Toxic_DeAlloc,
            QuickChatSelection::Custom_Toxic_404NoSkill,
            QuickChatSelection::Custom_Toxic_CatchVirus,
            QuickChatSelection::Custom_Useful_Passing,
            QuickChatSelection::Custom_Useful_Faking,
            QuickChatSelection::Custom_Useful_Demoing,
            QuickChatSelection::Custom_Useful_Bumping,
            QuickChatSelection::Custom_Compliments_TinyChances,
            QuickChatSelection::Custom_Compliments_SkillLevel,
            QuickChatSelection::Custom_Compliments_proud,
            QuickChatSelection::Custom_Compliments_GC,
            QuickChatSelection::Custom_Compliments_Pro,
        ];

        #[allow(non_camel_case_types)]
        const ENUM_NAMES_QUICK_CHAT_SELECTION: [&'static str; 58] = [
            "Information_IGotIt",
            "Information_NeedBoost",
            "Information_TakeTheShot",
            "Information_Defending",
            "Information_GoForIt",
            "Information_Centering",
            "Information_AllYours",
            "Information_InPosition",
            "Information_Incoming",
            "Compliments_NiceShot",
            "Compliments_GreatPass",
            "Compliments_Thanks",
            "Compliments_WhatASave",
            "Compliments_NiceOne",
            "Compliments_WhatAPlay",
            "Compliments_GreatClear",
            "Compliments_NiceBlock",
            "Reactions_OMG",
            "Reactions_Noooo",
            "Reactions_Wow",
            "Reactions_CloseOne",
            "Reactions_NoWay",
            "Reactions_HolyCow",
            "Reactions_Whew",
            "Reactions_Siiiick",
            "Reactions_Calculated",
            "Reactions_Savage",
            "Reactions_Okay",
            "Apologies_Cursing",
            "Apologies_NoProblem",
            "Apologies_Whoops",
            "Apologies_Sorry",
            "Apologies_MyBad",
            "Apologies_Oops",
            "Apologies_MyFault",
            "PostGame_Gg",
            "PostGame_WellPlayed",
            "PostGame_ThatWasFun",
            "PostGame_Rematch",
            "PostGame_OneMoreGame",
            "PostGame_WhatAGame",
            "PostGame_NiceMoves",
            "PostGame_EverybodyDance",
            "MaxPysonixQuickChatPresets",
            "Custom_Toxic_WasteCPU",
            "Custom_Toxic_GitGut",
            "Custom_Toxic_DeAlloc",
            "Custom_Toxic_404NoSkill",
            "Custom_Toxic_CatchVirus",
            "Custom_Useful_Passing",
            "Custom_Useful_Faking",
            "Custom_Useful_Demoing",
            "Custom_Useful_Bumping",
            "Custom_Compliments_TinyChances",
            "Custom_Compliments_SkillLevel",
            "Custom_Compliments_proud",
            "Custom_Compliments_GC",
            "Custom_Compliments_Pro",
        ];

        pub fn enum_name_quick_chat_selection(e: QuickChatSelection) -> &'static str {
            let index: usize = e as usize;
            ENUM_NAMES_QUICK_CHAT_SELECTION[index]
        }

        // struct Vector3, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Vector3 {
            x_: f32,
            y_: f32,
            z_: f32,
        } // pub struct Vector3
        impl flatbuffers::SafeSliceAccess for Vector3 {}
        impl<'a> flatbuffers::Follow<'a> for Vector3 {
            type Inner = &'a Vector3;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Vector3>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Vector3 {
            type Inner = &'a Vector3;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Vector3>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Vector3 {
            type Output = Vector3;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Vector3 as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Vector3 {
            type Output = Vector3;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Vector3 as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Vector3 {
            pub fn new<'a>(_x: f32, _y: f32, _z: f32) -> Self {
                Vector3 {
                    x_: _x.to_little_endian(),
                    y_: _y.to_little_endian(),
                    z_: _z.to_little_endian(),
                }
            }
            pub fn x<'a>(&'a self) -> f32 {
                self.x_.from_little_endian()
            }
            pub fn y<'a>(&'a self) -> f32 {
                self.y_.from_little_endian()
            }
            pub fn z<'a>(&'a self) -> f32 {
                self.z_.from_little_endian()
            }
        }

        // struct Rotator, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Rotator {
            pitch_: f32,
            yaw_: f32,
            roll_: f32,
        } // pub struct Rotator
        impl flatbuffers::SafeSliceAccess for Rotator {}
        impl<'a> flatbuffers::Follow<'a> for Rotator {
            type Inner = &'a Rotator;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Rotator>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Rotator {
            type Inner = &'a Rotator;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Rotator>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Rotator {
            type Output = Rotator;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Rotator as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Rotator {
            type Output = Rotator;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Rotator as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Rotator {
            pub fn new<'a>(_pitch: f32, _yaw: f32, _roll: f32) -> Self {
                Rotator {
                    pitch_: _pitch.to_little_endian(),
                    yaw_: _yaw.to_little_endian(),
                    roll_: _roll.to_little_endian(),
                }
            }
            pub fn pitch<'a>(&'a self) -> f32 {
                self.pitch_.from_little_endian()
            }
            pub fn yaw<'a>(&'a self) -> f32 {
                self.yaw_.from_little_endian()
            }
            pub fn roll<'a>(&'a self) -> f32 {
                self.roll_.from_little_endian()
            }
        }

        // struct Float, aligned to 4
        #[repr(C, align(4))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Float {
            val_: f32,
        } // pub struct Float
        impl flatbuffers::SafeSliceAccess for Float {}
        impl<'a> flatbuffers::Follow<'a> for Float {
            type Inner = &'a Float;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Float>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Float {
            type Inner = &'a Float;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Float>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Float {
            type Output = Float;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Float as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Float {
            type Output = Float;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Float as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Float {
            pub fn new<'a>(_val: f32) -> Self {
                Float {
                    val_: _val.to_little_endian(),
                }
            }
            pub fn val<'a>(&'a self) -> f32 {
                self.val_.from_little_endian()
            }
        }

        // struct Bool, aligned to 1
        #[repr(C, align(1))]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub struct Bool {
            val_: bool,
        } // pub struct Bool
        impl flatbuffers::SafeSliceAccess for Bool {}
        impl<'a> flatbuffers::Follow<'a> for Bool {
            type Inner = &'a Bool;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Bool>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Bool {
            type Inner = &'a Bool;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Bool>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Bool {
            type Output = Bool;
            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(self as *const Bool as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }
        impl<'b> flatbuffers::Push for &'b Bool {
            type Output = Bool;

            #[inline]
            fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                let src = unsafe {
                    ::std::slice::from_raw_parts(*self as *const Bool as *const u8, Self::size())
                };
                dst.copy_from_slice(src);
            }
        }

        impl Bool {
            pub fn new<'a>(_val: bool) -> Self {
                Bool {
                    val_: _val.to_little_endian(),
                }
            }
            pub fn val<'a>(&'a self) -> bool {
                self.val_.from_little_endian()
            }
        }

        pub enum ControllerStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct ControllerState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ControllerState<'a> {
            type Inner = ControllerState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> ControllerState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ControllerState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ControllerStateArgs,
            ) -> flatbuffers::WIPOffset<ControllerState<'bldr>> {
                let mut builder = ControllerStateBuilder::new(_fbb);
                builder.add_roll(args.roll);
                builder.add_yaw(args.yaw);
                builder.add_pitch(args.pitch);
                builder.add_steer(args.steer);
                builder.add_throttle(args.throttle);
                builder.add_handbrake(args.handbrake);
                builder.add_boost(args.boost);
                builder.add_jump(args.jump);
                builder.finish()
            }

            pub const VT_THROTTLE: flatbuffers::VOffsetT = 4;
            pub const VT_STEER: flatbuffers::VOffsetT = 6;
            pub const VT_PITCH: flatbuffers::VOffsetT = 8;
            pub const VT_YAW: flatbuffers::VOffsetT = 10;
            pub const VT_ROLL: flatbuffers::VOffsetT = 12;
            pub const VT_JUMP: flatbuffers::VOffsetT = 14;
            pub const VT_BOOST: flatbuffers::VOffsetT = 16;
            pub const VT_HANDBRAKE: flatbuffers::VOffsetT = 18;

            /// -1 for full reverse, 1 for full forward
            #[inline]
            pub fn throttle(&'a self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_THROTTLE, Some(0.0))
                    .unwrap()
            }
            /// -1 for full left, 1 for full right
            #[inline]
            pub fn steer(&'a self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_STEER, Some(0.0))
                    .unwrap()
            }
            /// -1 for nose down, 1 for nose up
            #[inline]
            pub fn pitch(&'a self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_PITCH, Some(0.0))
                    .unwrap()
            }
            /// -1 for full left, 1 for full right
            #[inline]
            pub fn yaw(&'a self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_YAW, Some(0.0))
                    .unwrap()
            }
            /// -1 for roll left, 1 for roll right
            #[inline]
            pub fn roll(&'a self) -> f32 {
                self._tab
                    .get::<f32>(ControllerState::VT_ROLL, Some(0.0))
                    .unwrap()
            }
            /// true if you want to press the jump button
            #[inline]
            pub fn jump(&'a self) -> bool {
                self._tab
                    .get::<bool>(ControllerState::VT_JUMP, Some(false))
                    .unwrap()
            }
            /// true if you want to press the boost button
            #[inline]
            pub fn boost(&'a self) -> bool {
                self._tab
                    .get::<bool>(ControllerState::VT_BOOST, Some(false))
                    .unwrap()
            }
            /// true if you want to press the handbrake button
            #[inline]
            pub fn handbrake(&'a self) -> bool {
                self._tab
                    .get::<bool>(ControllerState::VT_HANDBRAKE, Some(false))
                    .unwrap()
            }
        }

        pub struct ControllerStateArgs {
            pub throttle: f32,
            pub steer: f32,
            pub pitch: f32,
            pub yaw: f32,
            pub roll: f32,
            pub jump: bool,
            pub boost: bool,
            pub handbrake: bool,
        }
        impl<'a> Default for ControllerStateArgs {
            #[inline]
            fn default() -> Self {
                ControllerStateArgs {
                    throttle: 0.0,
                    steer: 0.0,
                    pitch: 0.0,
                    yaw: 0.0,
                    roll: 0.0,
                    jump: false,
                    boost: false,
                    handbrake: false,
                }
            }
        }
        pub struct ControllerStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ControllerStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_throttle(&mut self, throttle: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_THROTTLE, throttle, 0.0);
            }
            #[inline]
            pub fn add_steer(&mut self, steer: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_STEER, steer, 0.0);
            }
            #[inline]
            pub fn add_pitch(&mut self, pitch: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_PITCH, pitch, 0.0);
            }
            #[inline]
            pub fn add_yaw(&mut self, yaw: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_YAW, yaw, 0.0);
            }
            #[inline]
            pub fn add_roll(&mut self, roll: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_ROLL, roll, 0.0);
            }
            #[inline]
            pub fn add_jump(&mut self, jump: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_JUMP, jump, false);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_BOOST, boost, false);
            }
            #[inline]
            pub fn add_handbrake(&mut self, handbrake: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_HANDBRAKE, handbrake, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ControllerStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ControllerStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ControllerState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PlayerInputOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PlayerInput<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerInput<'a> {
            type Inner = PlayerInput<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PlayerInput<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerInput { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerInputArgs,
            ) -> flatbuffers::WIPOffset<PlayerInput<'bldr>> {
                let mut builder = PlayerInputBuilder::new(_fbb);
                if let Some(x) = args.controllerState {
                    builder.add_controllerState(x);
                }
                builder.add_playerIndex(args.playerIndex);
                builder.finish()
            }

            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;
            pub const VT_CONTROLLERSTATE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn playerIndex(&'a self) -> i32 {
                self._tab
                    .get::<i32>(PlayerInput::VT_PLAYERINDEX, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn controllerState(&'a self) -> Option<ControllerState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ControllerState<'a>>>(
                        PlayerInput::VT_CONTROLLERSTATE,
                        None,
                    )
            }
        }

        pub struct PlayerInputArgs<'a> {
            pub playerIndex: i32,
            pub controllerState: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
        }
        impl<'a> Default for PlayerInputArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerInputArgs {
                    playerIndex: 0,
                    controllerState: None,
                }
            }
        }
        pub struct PlayerInputBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerInputBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerInput::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn add_controllerState(
                &mut self,
                controllerState: flatbuffers::WIPOffset<ControllerState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ControllerState>>(
                        PlayerInput::VT_CONTROLLERSTATE,
                        controllerState,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerInputBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerInputBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInput<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum TouchOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Touch<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Touch<'a> {
            type Inner = Touch<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> Touch<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Touch { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TouchArgs<'args>,
            ) -> flatbuffers::WIPOffset<Touch<'bldr>> {
                let mut builder = TouchBuilder::new(_fbb);
                if let Some(x) = args.normal {
                    builder.add_normal(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_gameSeconds(args.gameSeconds);
                if let Some(x) = args.playerName {
                    builder.add_playerName(x);
                }
                builder.finish()
            }

            pub const VT_PLAYERNAME: flatbuffers::VOffsetT = 4;
            pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 6;
            pub const VT_LOCATION: flatbuffers::VOffsetT = 8;
            pub const VT_NORMAL: flatbuffers::VOffsetT = 10;

            /// The name of the player involved with the touch.
            #[inline]
            pub fn playerName(&'a self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Touch::VT_PLAYERNAME, None)
            }
            /// Seconds that had elapsed in the game when the touch occurred.
            #[inline]
            pub fn gameSeconds(&'a self) -> f32 {
                self._tab
                    .get::<f32>(Touch::VT_GAMESECONDS, Some(0.0))
                    .unwrap()
            }
            /// The point of contact for the touch.
            #[inline]
            pub fn location(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Touch::VT_LOCATION, None)
            }
            /// The direction of the touch.
            #[inline]
            pub fn normal(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Touch::VT_NORMAL, None)
            }
        }

        pub struct TouchArgs<'a> {
            pub playerName: Option<flatbuffers::WIPOffset<&'a str>>,
            pub gameSeconds: f32,
            pub location: Option<&'a Vector3>,
            pub normal: Option<&'a Vector3>,
        }
        impl<'a> Default for TouchArgs<'a> {
            #[inline]
            fn default() -> Self {
                TouchArgs {
                    playerName: None,
                    gameSeconds: 0.0,
                    location: None,
                    normal: None,
                }
            }
        }
        pub struct TouchBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TouchBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerName(&mut self, playerName: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Touch::VT_PLAYERNAME,
                    playerName,
                );
            }
            #[inline]
            pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
                self.fbb_
                    .push_slot::<f32>(Touch::VT_GAMESECONDS, gameSeconds, 0.0);
            }
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Touch::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_normal(&mut self, normal: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Touch::VT_NORMAL, normal);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TouchBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TouchBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Touch<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum ScoreInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct ScoreInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ScoreInfo<'a> {
            type Inner = ScoreInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> ScoreInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ScoreInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ScoreInfoArgs,
            ) -> flatbuffers::WIPOffset<ScoreInfo<'bldr>> {
                let mut builder = ScoreInfoBuilder::new(_fbb);
                builder.add_demolitions(args.demolitions);
                builder.add_shots(args.shots);
                builder.add_saves(args.saves);
                builder.add_assists(args.assists);
                builder.add_ownGoals(args.ownGoals);
                builder.add_goals(args.goals);
                builder.add_score(args.score);
                builder.finish()
            }

            pub const VT_SCORE: flatbuffers::VOffsetT = 4;
            pub const VT_GOALS: flatbuffers::VOffsetT = 6;
            pub const VT_OWNGOALS: flatbuffers::VOffsetT = 8;
            pub const VT_ASSISTS: flatbuffers::VOffsetT = 10;
            pub const VT_SAVES: flatbuffers::VOffsetT = 12;
            pub const VT_SHOTS: flatbuffers::VOffsetT = 14;
            pub const VT_DEMOLITIONS: flatbuffers::VOffsetT = 16;

            #[inline]
            pub fn score(&'a self) -> i32 {
                self._tab.get::<i32>(ScoreInfo::VT_SCORE, Some(0)).unwrap()
            }
            #[inline]
            pub fn goals(&'a self) -> i32 {
                self._tab.get::<i32>(ScoreInfo::VT_GOALS, Some(0)).unwrap()
            }
            #[inline]
            pub fn ownGoals(&'a self) -> i32 {
                self._tab
                    .get::<i32>(ScoreInfo::VT_OWNGOALS, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn assists(&'a self) -> i32 {
                self._tab
                    .get::<i32>(ScoreInfo::VT_ASSISTS, Some(0))
                    .unwrap()
            }
            #[inline]
            pub fn saves(&'a self) -> i32 {
                self._tab.get::<i32>(ScoreInfo::VT_SAVES, Some(0)).unwrap()
            }
            #[inline]
            pub fn shots(&'a self) -> i32 {
                self._tab.get::<i32>(ScoreInfo::VT_SHOTS, Some(0)).unwrap()
            }
            #[inline]
            pub fn demolitions(&'a self) -> i32 {
                self._tab
                    .get::<i32>(ScoreInfo::VT_DEMOLITIONS, Some(0))
                    .unwrap()
            }
        }

        pub struct ScoreInfoArgs {
            pub score: i32,
            pub goals: i32,
            pub ownGoals: i32,
            pub assists: i32,
            pub saves: i32,
            pub shots: i32,
            pub demolitions: i32,
        }
        impl<'a> Default for ScoreInfoArgs {
            #[inline]
            fn default() -> Self {
                ScoreInfoArgs {
                    score: 0,
                    goals: 0,
                    ownGoals: 0,
                    assists: 0,
                    saves: 0,
                    shots: 0,
                    demolitions: 0,
                }
            }
        }
        pub struct ScoreInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ScoreInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_score(&mut self, score: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SCORE, score, 0);
            }
            #[inline]
            pub fn add_goals(&mut self, goals: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_GOALS, goals, 0);
            }
            #[inline]
            pub fn add_ownGoals(&mut self, ownGoals: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_OWNGOALS, ownGoals, 0);
            }
            #[inline]
            pub fn add_assists(&mut self, assists: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_ASSISTS, assists, 0);
            }
            #[inline]
            pub fn add_saves(&mut self, saves: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SAVES, saves, 0);
            }
            #[inline]
            pub fn add_shots(&mut self, shots: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SHOTS, shots, 0);
            }
            #[inline]
            pub fn add_demolitions(&mut self, demolitions: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_DEMOLITIONS, demolitions, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ScoreInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ScoreInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ScoreInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PhysicsOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Physics<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Physics<'a> {
            type Inner = Physics<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> Physics<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Physics { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PhysicsArgs,
            ) -> flatbuffers::WIPOffset<Physics<'bldr>> {
                let mut builder = PhysicsBuilder::new(_fbb);
                if let Some(x) = args.angularVelocity {
                    builder.add_angularVelocity(x);
                }
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub fn location(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Physics::VT_LOCATION, None)
            }
            #[inline]
            pub fn rotation(&'a self) -> Option<&'a Rotator> {
                self._tab.get::<Rotator>(Physics::VT_ROTATION, None)
            }
            #[inline]
            pub fn velocity(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Physics::VT_VELOCITY, None)
            }
            #[inline]
            pub fn angularVelocity(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(Physics::VT_ANGULARVELOCITY, None)
            }
        }

        pub struct PhysicsArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub rotation: Option<&'a Rotator>,
            pub velocity: Option<&'a Vector3>,
            pub angularVelocity: Option<&'a Vector3>,
        }
        impl<'a> Default for PhysicsArgs<'a> {
            #[inline]
            fn default() -> Self {
                PhysicsArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }
        pub struct PhysicsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PhysicsBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: &'b Rotator) {
                self.fbb_
                    .push_slot_always::<&Rotator>(Physics::VT_ROTATION, rotation);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn add_angularVelocity(&mut self, angularVelocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_ANGULARVELOCITY, angularVelocity);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PhysicsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PhysicsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Physics<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PlayerInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PlayerInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerInfo<'a> {
            type Inner = PlayerInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PlayerInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerInfo<'bldr>> {
                let mut builder = PlayerInfoBuilder::new(_fbb);
                builder.add_boost(args.boost);
                builder.add_team(args.team);
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                if let Some(x) = args.scoreInfo {
                    builder.add_scoreInfo(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.add_doubleJumped(args.doubleJumped);
                builder.add_jumped(args.jumped);
                builder.add_isBot(args.isBot);
                builder.add_isSupersonic(args.isSupersonic);
                builder.add_hasWheelContact(args.hasWheelContact);
                builder.add_isDemolished(args.isDemolished);
                builder.finish()
            }

            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_SCOREINFO: flatbuffers::VOffsetT = 6;
            pub const VT_ISDEMOLISHED: flatbuffers::VOffsetT = 8;
            pub const VT_HASWHEELCONTACT: flatbuffers::VOffsetT = 10;
            pub const VT_ISSUPERSONIC: flatbuffers::VOffsetT = 12;
            pub const VT_ISBOT: flatbuffers::VOffsetT = 14;
            pub const VT_JUMPED: flatbuffers::VOffsetT = 16;
            pub const VT_DOUBLEJUMPED: flatbuffers::VOffsetT = 18;
            pub const VT_NAME: flatbuffers::VOffsetT = 20;
            pub const VT_TEAM: flatbuffers::VOffsetT = 22;
            pub const VT_BOOST: flatbuffers::VOffsetT = 24;

            #[inline]
            pub fn physics(&'a self) -> Option<Physics<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Physics<'a>>>(PlayerInfo::VT_PHYSICS, None)
            }
            #[inline]
            pub fn scoreInfo(&'a self) -> Option<ScoreInfo<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ScoreInfo<'a>>>(
                        PlayerInfo::VT_SCOREINFO,
                        None,
                    )
            }
            #[inline]
            pub fn isDemolished(&'a self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_ISDEMOLISHED, Some(false))
                    .unwrap()
            }
            /// True if your wheels are on the ground, the wall, or the
            /// ceiling. False if you're midair or turtling.
            #[inline]
            pub fn hasWheelContact(&'a self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_HASWHEELCONTACT, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn isSupersonic(&'a self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_ISSUPERSONIC, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn isBot(&'a self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_ISBOT, Some(false))
                    .unwrap()
            }
            /// True if the player has jumped. Falling off the ceiling /
            /// driving off the goal post does not count.
            #[inline]
            pub fn jumped(&'a self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_JUMPED, Some(false))
                    .unwrap()
            }
            /// True if player has double jumped. False does not mean you have
            /// a jump remaining, because the aerial timer can run
            /// out, and that doesn't affect this flag.
            #[inline]
            pub fn doubleJumped(&'a self) -> bool {
                self._tab
                    .get::<bool>(PlayerInfo::VT_DOUBLEJUMPED, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn name(&'a self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PlayerInfo::VT_NAME, None)
            }
            #[inline]
            pub fn team(&'a self) -> i32 {
                self._tab.get::<i32>(PlayerInfo::VT_TEAM, Some(0)).unwrap()
            }
            #[inline]
            pub fn boost(&'a self) -> i32 {
                self._tab.get::<i32>(PlayerInfo::VT_BOOST, Some(0)).unwrap()
            }
        }

        pub struct PlayerInfoArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
            pub scoreInfo: Option<flatbuffers::WIPOffset<ScoreInfo<'a>>>,
            pub isDemolished: bool,
            pub hasWheelContact: bool,
            pub isSupersonic: bool,
            pub isBot: bool,
            pub jumped: bool,
            pub doubleJumped: bool,
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub team: i32,
            pub boost: i32,
        }
        impl<'a> Default for PlayerInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerInfoArgs {
                    physics: None,
                    scoreInfo: None,
                    isDemolished: false,
                    hasWheelContact: false,
                    isSupersonic: false,
                    isBot: false,
                    jumped: false,
                    doubleJumped: false,
                    name: None,
                    team: 0,
                    boost: 0,
                }
            }
        }
        pub struct PlayerInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics>>(
                        PlayerInfo::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_scoreInfo(&mut self, scoreInfo: flatbuffers::WIPOffset<ScoreInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ScoreInfo>>(
                        PlayerInfo::VT_SCOREINFO,
                        scoreInfo,
                    );
            }
            #[inline]
            pub fn add_isDemolished(&mut self, isDemolished: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISDEMOLISHED, isDemolished, false);
            }
            #[inline]
            pub fn add_hasWheelContact(&mut self, hasWheelContact: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_HASWHEELCONTACT, hasWheelContact, false);
            }
            #[inline]
            pub fn add_isSupersonic(&mut self, isSupersonic: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISSUPERSONIC, isSupersonic, false);
            }
            #[inline]
            pub fn add_isBot(&mut self, isBot: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISBOT, isBot, false);
            }
            #[inline]
            pub fn add_jumped(&mut self, jumped: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_JUMPED, jumped, false);
            }
            #[inline]
            pub fn add_doubleJumped(&mut self, doubleJumped: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_DOUBLEJUMPED, doubleJumped, false);
            }
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(PlayerInfo::VT_NAME, name);
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_.push_slot::<i32>(PlayerInfo::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: i32) {
                self.fbb_.push_slot::<i32>(PlayerInfo::VT_BOOST, boost, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BallInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BallInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BallInfo<'a> {
            type Inner = BallInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BallInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BallInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BallInfoArgs,
            ) -> flatbuffers::WIPOffset<BallInfo<'bldr>> {
                let mut builder = BallInfoBuilder::new(_fbb);
                if let Some(x) = args.latestTouch {
                    builder.add_latestTouch(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.finish()
            }

            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_LATESTTOUCH: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn physics(&'a self) -> Option<Physics<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Physics<'a>>>(BallInfo::VT_PHYSICS, None)
            }
            #[inline]
            pub fn latestTouch(&'a self) -> Option<Touch<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Touch<'a>>>(BallInfo::VT_LATESTTOUCH, None)
            }
        }

        pub struct BallInfoArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
            pub latestTouch: Option<flatbuffers::WIPOffset<Touch<'a>>>,
        }
        impl<'a> Default for BallInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                BallInfoArgs {
                    physics: None,
                    latestTouch: None,
                }
            }
        }
        pub struct BallInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BallInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics>>(
                        BallInfo::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_latestTouch(&mut self, latestTouch: flatbuffers::WIPOffset<Touch<'b>>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Touch>>(
                    BallInfo::VT_LATESTTOUCH,
                    latestTouch,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BallInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BallInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BallInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BoostPadStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BoostPadState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BoostPadState<'a> {
            type Inner = BoostPadState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BoostPadState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BoostPadState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoostPadStateArgs,
            ) -> flatbuffers::WIPOffset<BoostPadState<'bldr>> {
                let mut builder = BoostPadStateBuilder::new(_fbb);
                builder.add_timer(args.timer);
                builder.add_isActive(args.isActive);
                builder.finish()
            }

            pub const VT_ISACTIVE: flatbuffers::VOffsetT = 4;
            pub const VT_TIMER: flatbuffers::VOffsetT = 6;

            /// True if the boost can be picked up
            #[inline]
            pub fn isActive(&'a self) -> bool {
                self._tab
                    .get::<bool>(BoostPadState::VT_ISACTIVE, Some(false))
                    .unwrap()
            }
            /// The number of seconds since the boost has been picked up, or
            /// 0.0 if the boost is active.
            #[inline]
            pub fn timer(&'a self) -> f32 {
                self._tab
                    .get::<f32>(BoostPadState::VT_TIMER, Some(0.0))
                    .unwrap()
            }
        }

        pub struct BoostPadStateArgs {
            pub isActive: bool,
            pub timer: f32,
        }
        impl<'a> Default for BoostPadStateArgs {
            #[inline]
            fn default() -> Self {
                BoostPadStateArgs {
                    isActive: false,
                    timer: 0.0,
                }
            }
        }
        pub struct BoostPadStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoostPadStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_isActive(&mut self, isActive: bool) {
                self.fbb_
                    .push_slot::<bool>(BoostPadState::VT_ISACTIVE, isActive, false);
            }
            #[inline]
            pub fn add_timer(&mut self, timer: f32) {
                self.fbb_
                    .push_slot::<f32>(BoostPadState::VT_TIMER, timer, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BoostPadStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoostPadStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BoostPadState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DropshotTileOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DropshotTile<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DropshotTile<'a> {
            type Inner = DropshotTile<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DropshotTile<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DropshotTile { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DropshotTileArgs,
            ) -> flatbuffers::WIPOffset<DropshotTile<'bldr>> {
                let mut builder = DropshotTileBuilder::new(_fbb);
                builder.add_tileState(args.tileState);
                builder.finish()
            }

            pub const VT_TILESTATE: flatbuffers::VOffsetT = 4;

            /// True if the tile is damaged
            #[inline]
            pub fn tileState(&'a self) -> TileState {
                self._tab
                    .get::<TileState>(DropshotTile::VT_TILESTATE, Some(TileState::Unknown))
                    .unwrap()
            }
        }

        pub struct DropshotTileArgs {
            pub tileState: TileState,
        }
        impl<'a> Default for DropshotTileArgs {
            #[inline]
            fn default() -> Self {
                DropshotTileArgs {
                    tileState: TileState::Unknown,
                }
            }
        }
        pub struct DropshotTileBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DropshotTileBuilder<'a, 'b> {
            #[inline]
            pub fn add_tileState(&mut self, tileState: TileState) {
                self.fbb_.push_slot::<TileState>(
                    DropshotTile::VT_TILESTATE,
                    tileState,
                    TileState::Unknown,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DropshotTileBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DropshotTileBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DropshotTile<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum GameInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct GameInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GameInfo<'a> {
            type Inner = GameInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> GameInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GameInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GameInfoArgs,
            ) -> flatbuffers::WIPOffset<GameInfo<'bldr>> {
                let mut builder = GameInfoBuilder::new(_fbb);
                builder.add_gameTimeRemaining(args.gameTimeRemaining);
                builder.add_secondsElapsed(args.secondsElapsed);
                builder.add_isMatchEnded(args.isMatchEnded);
                builder.add_isKickoffPause(args.isKickoffPause);
                builder.add_isRoundActive(args.isRoundActive);
                builder.add_isUnlimitedTime(args.isUnlimitedTime);
                builder.add_isOvertime(args.isOvertime);
                builder.finish()
            }

            pub const VT_SECONDSELAPSED: flatbuffers::VOffsetT = 4;
            pub const VT_GAMETIMEREMAINING: flatbuffers::VOffsetT = 6;
            pub const VT_ISOVERTIME: flatbuffers::VOffsetT = 8;
            pub const VT_ISUNLIMITEDTIME: flatbuffers::VOffsetT = 10;
            pub const VT_ISROUNDACTIVE: flatbuffers::VOffsetT = 12;
            pub const VT_ISKICKOFFPAUSE: flatbuffers::VOffsetT = 14;
            pub const VT_ISMATCHENDED: flatbuffers::VOffsetT = 16;

            #[inline]
            pub fn secondsElapsed(&'a self) -> f32 {
                self._tab
                    .get::<f32>(GameInfo::VT_SECONDSELAPSED, Some(0.0))
                    .unwrap()
            }
            #[inline]
            pub fn gameTimeRemaining(&'a self) -> f32 {
                self._tab
                    .get::<f32>(GameInfo::VT_GAMETIMEREMAINING, Some(0.0))
                    .unwrap()
            }
            #[inline]
            pub fn isOvertime(&'a self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISOVERTIME, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn isUnlimitedTime(&'a self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISUNLIMITEDTIME, Some(false))
                    .unwrap()
            }
            /// True when cars are allowed to move, and during the pause menu.
            /// False during replays.
            #[inline]
            pub fn isRoundActive(&'a self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISROUNDACTIVE, Some(false))
                    .unwrap()
            }
            /// Only true during a kickoff, when the car is allowed to move,
            /// and the ball has not been hit, and the game clock
            /// has not started yet. If both players sit still, game clock will
            /// eventually start and this will become false.
            #[inline]
            pub fn isKickoffPause(&'a self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISKICKOFFPAUSE, Some(false))
                    .unwrap()
            }
            /// Turns true after final replay, the moment the 'winner' screen
            /// appears. Remains true during next match
            /// countdown. Turns false again the moment the 'choose team'
            /// screen appears.
            #[inline]
            pub fn isMatchEnded(&'a self) -> bool {
                self._tab
                    .get::<bool>(GameInfo::VT_ISMATCHENDED, Some(false))
                    .unwrap()
            }
        }

        pub struct GameInfoArgs {
            pub secondsElapsed: f32,
            pub gameTimeRemaining: f32,
            pub isOvertime: bool,
            pub isUnlimitedTime: bool,
            pub isRoundActive: bool,
            pub isKickoffPause: bool,
            pub isMatchEnded: bool,
        }
        impl<'a> Default for GameInfoArgs {
            #[inline]
            fn default() -> Self {
                GameInfoArgs {
                    secondsElapsed: 0.0,
                    gameTimeRemaining: 0.0,
                    isOvertime: false,
                    isUnlimitedTime: false,
                    isRoundActive: false,
                    isKickoffPause: false,
                    isMatchEnded: false,
                }
            }
        }
        pub struct GameInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GameInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_secondsElapsed(&mut self, secondsElapsed: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_SECONDSELAPSED, secondsElapsed, 0.0);
            }
            #[inline]
            pub fn add_gameTimeRemaining(&mut self, gameTimeRemaining: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_GAMETIMEREMAINING, gameTimeRemaining, 0.0);
            }
            #[inline]
            pub fn add_isOvertime(&mut self, isOvertime: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISOVERTIME, isOvertime, false);
            }
            #[inline]
            pub fn add_isUnlimitedTime(&mut self, isUnlimitedTime: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISUNLIMITEDTIME, isUnlimitedTime, false);
            }
            #[inline]
            pub fn add_isRoundActive(&mut self, isRoundActive: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISROUNDACTIVE, isRoundActive, false);
            }
            #[inline]
            pub fn add_isKickoffPause(&mut self, isKickoffPause: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISKICKOFFPAUSE, isKickoffPause, false);
            }
            #[inline]
            pub fn add_isMatchEnded(&mut self, isMatchEnded: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISMATCHENDED, isMatchEnded, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GameInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GameInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GameInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum GameTickPacketOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct GameTickPacket<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GameTickPacket<'a> {
            type Inner = GameTickPacket<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> GameTickPacket<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GameTickPacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GameTickPacketArgs<'args>,
            ) -> flatbuffers::WIPOffset<GameTickPacket<'bldr>> {
                let mut builder = GameTickPacketBuilder::new(_fbb);
                if let Some(x) = args.tileInformation {
                    builder.add_tileInformation(x);
                }
                if let Some(x) = args.gameInfo {
                    builder.add_gameInfo(x);
                }
                if let Some(x) = args.ball {
                    builder.add_ball(x);
                }
                if let Some(x) = args.boostPadStates {
                    builder.add_boostPadStates(x);
                }
                if let Some(x) = args.players {
                    builder.add_players(x);
                }
                builder.finish()
            }

            pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;
            pub const VT_BOOSTPADSTATES: flatbuffers::VOffsetT = 6;
            pub const VT_BALL: flatbuffers::VOffsetT = 8;
            pub const VT_GAMEINFO: flatbuffers::VOffsetT = 10;
            pub const VT_TILEINFORMATION: flatbuffers::VOffsetT = 12;

            #[inline]
            pub fn players(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>,
                >>(GameTickPacket::VT_PLAYERS, None)
            }
            #[inline]
            pub fn boostPadStates(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BoostPadState<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<BoostPadState<'a>>>,
                >>(GameTickPacket::VT_BOOSTPADSTATES, None)
            }
            #[inline]
            pub fn ball(&'a self) -> Option<BallInfo<'a>> {
                self._tab.get::<flatbuffers::ForwardsUOffset<BallInfo<'a>>>(
                    GameTickPacket::VT_BALL,
                    None,
                )
            }
            #[inline]
            pub fn gameInfo(&'a self) -> Option<GameInfo<'a>> {
                self._tab.get::<flatbuffers::ForwardsUOffset<GameInfo<'a>>>(
                    GameTickPacket::VT_GAMEINFO,
                    None,
                )
            }
            #[inline]
            pub fn tileInformation(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<DropshotTile<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<DropshotTile<'a>>>,
                >>(GameTickPacket::VT_TILEINFORMATION, None)
            }
        }

        pub struct GameTickPacketArgs<'a> {
            pub players: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>,
                >,
            >,
            pub boostPadStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPadState<'a>>>,
                >,
            >,
            pub ball: Option<flatbuffers::WIPOffset<BallInfo<'a>>>,
            pub gameInfo: Option<flatbuffers::WIPOffset<GameInfo<'a>>>,
            pub tileInformation: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DropshotTile<'a>>>,
                >,
            >,
        }
        impl<'a> Default for GameTickPacketArgs<'a> {
            #[inline]
            fn default() -> Self {
                GameTickPacketArgs {
                    players: None,
                    boostPadStates: None,
                    ball: None,
                    gameInfo: None,
                    tileInformation: None,
                }
            }
        }
        pub struct GameTickPacketBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GameTickPacketBuilder<'a, 'b> {
            #[inline]
            pub fn add_players(
                &mut self,
                players: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlayerInfo<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_PLAYERS,
                    players,
                );
            }
            #[inline]
            pub fn add_boostPadStates(
                &mut self,
                boostPadStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BoostPadState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_BOOSTPADSTATES,
                    boostPadStates,
                );
            }
            #[inline]
            pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<BallInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<BallInfo>>(
                        GameTickPacket::VT_BALL,
                        ball,
                    );
            }
            #[inline]
            pub fn add_gameInfo(&mut self, gameInfo: flatbuffers::WIPOffset<GameInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<GameInfo>>(
                        GameTickPacket::VT_GAMEINFO,
                        gameInfo,
                    );
            }
            #[inline]
            pub fn add_tileInformation(
                &mut self,
                tileInformation: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DropshotTile<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_TILEINFORMATION,
                    tileInformation,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GameTickPacketBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GameTickPacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GameTickPacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum GoalInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct GoalInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GoalInfo<'a> {
            type Inner = GoalInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> GoalInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GoalInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GoalInfoArgs,
            ) -> flatbuffers::WIPOffset<GoalInfo<'bldr>> {
                let mut builder = GoalInfoBuilder::new(_fbb);
                if let Some(x) = args.direction {
                    builder.add_direction(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_teamNum(args.teamNum);
                builder.finish()
            }

            pub const VT_TEAMNUM: flatbuffers::VOffsetT = 4;
            pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
            pub const VT_DIRECTION: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn teamNum(&'a self) -> i32 {
                self._tab.get::<i32>(GoalInfo::VT_TEAMNUM, Some(0)).unwrap()
            }
            #[inline]
            pub fn location(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(GoalInfo::VT_LOCATION, None)
            }
            #[inline]
            pub fn direction(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(GoalInfo::VT_DIRECTION, None)
            }
        }

        pub struct GoalInfoArgs<'a> {
            pub teamNum: i32,
            pub location: Option<&'a Vector3>,
            pub direction: Option<&'a Vector3>,
        }
        impl<'a> Default for GoalInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                GoalInfoArgs {
                    teamNum: 0,
                    location: None,
                    direction: None,
                }
            }
        }
        pub struct GoalInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GoalInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_teamNum(&mut self, teamNum: i32) {
                self.fbb_.push_slot::<i32>(GoalInfo::VT_TEAMNUM, teamNum, 0);
            }
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(GoalInfo::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_direction(&mut self, direction: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(GoalInfo::VT_DIRECTION, direction);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GoalInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GoalInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GoalInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BoostPadOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BoostPad<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BoostPad<'a> {
            type Inner = BoostPad<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BoostPad<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BoostPad { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoostPadArgs,
            ) -> flatbuffers::WIPOffset<BoostPad<'bldr>> {
                let mut builder = BoostPadBuilder::new(_fbb);
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_isFullBoost(args.isFullBoost);
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ISFULLBOOST: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn location(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(BoostPad::VT_LOCATION, None)
            }
            #[inline]
            pub fn isFullBoost(&'a self) -> bool {
                self._tab
                    .get::<bool>(BoostPad::VT_ISFULLBOOST, Some(false))
                    .unwrap()
            }
        }

        pub struct BoostPadArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub isFullBoost: bool,
        }
        impl<'a> Default for BoostPadArgs<'a> {
            #[inline]
            fn default() -> Self {
                BoostPadArgs {
                    location: None,
                    isFullBoost: false,
                }
            }
        }
        pub struct BoostPadBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoostPadBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(BoostPad::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_isFullBoost(&mut self, isFullBoost: bool) {
                self.fbb_
                    .push_slot::<bool>(BoostPad::VT_ISFULLBOOST, isFullBoost, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BoostPadBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoostPadBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BoostPad<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum FieldInfoOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct FieldInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FieldInfo<'a> {
            type Inner = FieldInfo<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> FieldInfo<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FieldInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args FieldInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<FieldInfo<'bldr>> {
                let mut builder = FieldInfoBuilder::new(_fbb);
                if let Some(x) = args.goals {
                    builder.add_goals(x);
                }
                if let Some(x) = args.boostPads {
                    builder.add_boostPads(x);
                }
                builder.finish()
            }

            pub const VT_BOOSTPADS: flatbuffers::VOffsetT = 4;
            pub const VT_GOALS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn boostPads(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<BoostPad<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<BoostPad<'a>>>,
                >>(FieldInfo::VT_BOOSTPADS, None)
            }
            #[inline]
            pub fn goals(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<GoalInfo<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<GoalInfo<'a>>>,
                >>(FieldInfo::VT_GOALS, None)
            }
        }

        pub struct FieldInfoArgs<'a> {
            pub boostPads: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPad<'a>>>,
                >,
            >,
            pub goals: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GoalInfo<'a>>>,
                >,
            >,
        }
        impl<'a> Default for FieldInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                FieldInfoArgs {
                    boostPads: None,
                    goals: None,
                }
            }
        }
        pub struct FieldInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> FieldInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_boostPads(
                &mut self,
                boostPads: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BoostPad<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    FieldInfo::VT_BOOSTPADS,
                    boostPads,
                );
            }
            #[inline]
            pub fn add_goals(
                &mut self,
                goals: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<GoalInfo<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FieldInfo::VT_GOALS, goals);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> FieldInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                FieldInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FieldInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum Vector3PartialOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Vector3Partial<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Vector3Partial<'a> {
            type Inner = Vector3Partial<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> Vector3Partial<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Vector3Partial { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args Vector3PartialArgs,
            ) -> flatbuffers::WIPOffset<Vector3Partial<'bldr>> {
                let mut builder = Vector3PartialBuilder::new(_fbb);
                if let Some(x) = args.z {
                    builder.add_z(x);
                }
                if let Some(x) = args.y {
                    builder.add_y(x);
                }
                if let Some(x) = args.x {
                    builder.add_x(x);
                }
                builder.finish()
            }

            pub const VT_X: flatbuffers::VOffsetT = 4;
            pub const VT_Y: flatbuffers::VOffsetT = 6;
            pub const VT_Z: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn x(&'a self) -> Option<&'a Float> {
                self._tab.get::<Float>(Vector3Partial::VT_X, None)
            }
            #[inline]
            pub fn y(&'a self) -> Option<&'a Float> {
                self._tab.get::<Float>(Vector3Partial::VT_Y, None)
            }
            #[inline]
            pub fn z(&'a self) -> Option<&'a Float> {
                self._tab.get::<Float>(Vector3Partial::VT_Z, None)
            }
        }

        pub struct Vector3PartialArgs<'a> {
            pub x: Option<&'a Float>,
            pub y: Option<&'a Float>,
            pub z: Option<&'a Float>,
        }
        impl<'a> Default for Vector3PartialArgs<'a> {
            #[inline]
            fn default() -> Self {
                Vector3PartialArgs {
                    x: None,
                    y: None,
                    z: None,
                }
            }
        }
        pub struct Vector3PartialBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> Vector3PartialBuilder<'a, 'b> {
            #[inline]
            pub fn add_x(&mut self, x: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_X, x);
            }
            #[inline]
            pub fn add_y(&mut self, y: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_Y, y);
            }
            #[inline]
            pub fn add_z(&mut self, z: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_Z, z);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> Vector3PartialBuilder<'a, 'b> {
                let start = _fbb.start_table();
                Vector3PartialBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Vector3Partial<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum RotatorPartialOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RotatorPartial<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RotatorPartial<'a> {
            type Inner = RotatorPartial<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RotatorPartial<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RotatorPartial { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RotatorPartialArgs,
            ) -> flatbuffers::WIPOffset<RotatorPartial<'bldr>> {
                let mut builder = RotatorPartialBuilder::new(_fbb);
                if let Some(x) = args.roll {
                    builder.add_roll(x);
                }
                if let Some(x) = args.yaw {
                    builder.add_yaw(x);
                }
                if let Some(x) = args.pitch {
                    builder.add_pitch(x);
                }
                builder.finish()
            }

            pub const VT_PITCH: flatbuffers::VOffsetT = 4;
            pub const VT_YAW: flatbuffers::VOffsetT = 6;
            pub const VT_ROLL: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn pitch(&'a self) -> Option<&'a Float> {
                self._tab.get::<Float>(RotatorPartial::VT_PITCH, None)
            }
            #[inline]
            pub fn yaw(&'a self) -> Option<&'a Float> {
                self._tab.get::<Float>(RotatorPartial::VT_YAW, None)
            }
            #[inline]
            pub fn roll(&'a self) -> Option<&'a Float> {
                self._tab.get::<Float>(RotatorPartial::VT_ROLL, None)
            }
        }

        pub struct RotatorPartialArgs<'a> {
            pub pitch: Option<&'a Float>,
            pub yaw: Option<&'a Float>,
            pub roll: Option<&'a Float>,
        }
        impl<'a> Default for RotatorPartialArgs<'a> {
            #[inline]
            fn default() -> Self {
                RotatorPartialArgs {
                    pitch: None,
                    yaw: None,
                    roll: None,
                }
            }
        }
        pub struct RotatorPartialBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RotatorPartialBuilder<'a, 'b> {
            #[inline]
            pub fn add_pitch(&mut self, pitch: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_PITCH, pitch);
            }
            #[inline]
            pub fn add_yaw(&mut self, yaw: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_YAW, yaw);
            }
            #[inline]
            pub fn add_roll(&mut self, roll: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_ROLL, roll);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RotatorPartialBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RotatorPartialBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RotatorPartial<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredPhysicsOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredPhysics<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredPhysics<'a> {
            type Inner = DesiredPhysics<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredPhysics<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredPhysics { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredPhysicsArgs,
            ) -> flatbuffers::WIPOffset<DesiredPhysics<'bldr>> {
                let mut builder = DesiredPhysicsBuilder::new(_fbb);
                if let Some(x) = args.angularVelocity {
                    builder.add_angularVelocity(x);
                }
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub fn location(&'a self) -> Option<Vector3Partial<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Vector3Partial<'a>>>(
                        DesiredPhysics::VT_LOCATION,
                        None,
                    )
            }
            #[inline]
            pub fn rotation(&'a self) -> Option<RotatorPartial<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<RotatorPartial<'a>>>(
                        DesiredPhysics::VT_ROTATION,
                        None,
                    )
            }
            #[inline]
            pub fn velocity(&'a self) -> Option<Vector3Partial<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Vector3Partial<'a>>>(
                        DesiredPhysics::VT_VELOCITY,
                        None,
                    )
            }
            #[inline]
            pub fn angularVelocity(&'a self) -> Option<Vector3Partial<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Vector3Partial<'a>>>(
                        DesiredPhysics::VT_ANGULARVELOCITY,
                        None,
                    )
            }
        }

        pub struct DesiredPhysicsArgs<'a> {
            pub location: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
            pub rotation: Option<flatbuffers::WIPOffset<RotatorPartial<'a>>>,
            pub velocity: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
            pub angularVelocity: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
        }
        impl<'a> Default for DesiredPhysicsArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredPhysicsArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }
        pub struct DesiredPhysicsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredPhysicsBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: flatbuffers::WIPOffset<Vector3Partial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(
                        DesiredPhysics::VT_LOCATION,
                        location,
                    );
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: flatbuffers::WIPOffset<RotatorPartial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<RotatorPartial>>(
                        DesiredPhysics::VT_ROTATION,
                        rotation,
                    );
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: flatbuffers::WIPOffset<Vector3Partial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(
                        DesiredPhysics::VT_VELOCITY,
                        velocity,
                    );
            }
            #[inline]
            pub fn add_angularVelocity(
                &mut self,
                angularVelocity: flatbuffers::WIPOffset<Vector3Partial<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(
                        DesiredPhysics::VT_ANGULARVELOCITY,
                        angularVelocity,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredPhysicsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredPhysicsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredPhysics<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredBallStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredBallState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredBallState<'a> {
            type Inner = DesiredBallState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredBallState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredBallState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredBallStateArgs,
            ) -> flatbuffers::WIPOffset<DesiredBallState<'bldr>> {
                let mut builder = DesiredBallStateBuilder::new(_fbb);
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.finish()
            }

            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn physics(&'a self) -> Option<DesiredPhysics<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DesiredPhysics<'a>>>(
                        DesiredBallState::VT_PHYSICS,
                        None,
                    )
            }
        }

        pub struct DesiredBallStateArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<DesiredPhysics<'a>>>,
        }
        impl<'a> Default for DesiredBallStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredBallStateArgs { physics: None }
            }
        }
        pub struct DesiredBallStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredBallStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<DesiredPhysics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredPhysics>>(
                        DesiredBallState::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredBallStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredBallStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredBallState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredCarStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredCarState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredCarState<'a> {
            type Inner = DesiredCarState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredCarState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredCarState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredCarStateArgs,
            ) -> flatbuffers::WIPOffset<DesiredCarState<'bldr>> {
                let mut builder = DesiredCarStateBuilder::new(_fbb);
                if let Some(x) = args.doubleJumped {
                    builder.add_doubleJumped(x);
                }
                if let Some(x) = args.jumped {
                    builder.add_jumped(x);
                }
                if let Some(x) = args.boostAmount {
                    builder.add_boostAmount(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.finish()
            }

            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_BOOSTAMOUNT: flatbuffers::VOffsetT = 6;
            pub const VT_JUMPED: flatbuffers::VOffsetT = 8;
            pub const VT_DOUBLEJUMPED: flatbuffers::VOffsetT = 10;

            #[inline]
            pub fn physics(&'a self) -> Option<DesiredPhysics<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DesiredPhysics<'a>>>(
                        DesiredCarState::VT_PHYSICS,
                        None,
                    )
            }
            #[inline]
            pub fn boostAmount(&'a self) -> Option<&'a Float> {
                self._tab
                    .get::<Float>(DesiredCarState::VT_BOOSTAMOUNT, None)
            }
            #[inline]
            pub fn jumped(&'a self) -> Option<&'a Bool> {
                self._tab.get::<Bool>(DesiredCarState::VT_JUMPED, None)
            }
            #[inline]
            pub fn doubleJumped(&'a self) -> Option<&'a Bool> {
                self._tab
                    .get::<Bool>(DesiredCarState::VT_DOUBLEJUMPED, None)
            }
        }

        pub struct DesiredCarStateArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<DesiredPhysics<'a>>>,
            pub boostAmount: Option<&'a Float>,
            pub jumped: Option<&'a Bool>,
            pub doubleJumped: Option<&'a Bool>,
        }
        impl<'a> Default for DesiredCarStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredCarStateArgs {
                    physics: None,
                    boostAmount: None,
                    jumped: None,
                    doubleJumped: None,
                }
            }
        }
        pub struct DesiredCarStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredCarStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<DesiredPhysics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredPhysics>>(
                        DesiredCarState::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_boostAmount(&mut self, boostAmount: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(DesiredCarState::VT_BOOSTAMOUNT, boostAmount);
            }
            #[inline]
            pub fn add_jumped(&mut self, jumped: &'b Bool) {
                self.fbb_
                    .push_slot_always::<&Bool>(DesiredCarState::VT_JUMPED, jumped);
            }
            #[inline]
            pub fn add_doubleJumped(&mut self, doubleJumped: &'b Bool) {
                self.fbb_
                    .push_slot_always::<&Bool>(DesiredCarState::VT_DOUBLEJUMPED, doubleJumped);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredCarStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredCarStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredCarState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredBoostStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredBoostState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredBoostState<'a> {
            type Inner = DesiredBoostState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredBoostState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredBoostState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredBoostStateArgs,
            ) -> flatbuffers::WIPOffset<DesiredBoostState<'bldr>> {
                let mut builder = DesiredBoostStateBuilder::new(_fbb);
                if let Some(x) = args.respawnTime {
                    builder.add_respawnTime(x);
                }
                builder.finish()
            }

            pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub fn respawnTime(&'a self) -> Option<&'a Float> {
                self._tab
                    .get::<Float>(DesiredBoostState::VT_RESPAWNTIME, None)
            }
        }

        pub struct DesiredBoostStateArgs<'a> {
            pub respawnTime: Option<&'a Float>,
        }
        impl<'a> Default for DesiredBoostStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredBoostStateArgs { respawnTime: None }
            }
        }
        pub struct DesiredBoostStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredBoostStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_respawnTime(&mut self, respawnTime: &'b Float) {
                self.fbb_
                    .push_slot_always::<&Float>(DesiredBoostState::VT_RESPAWNTIME, respawnTime);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredBoostStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredBoostStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredBoostState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum DesiredGameStateOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct DesiredGameState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredGameState<'a> {
            type Inner = DesiredGameState<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> DesiredGameState<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredGameState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredGameStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredGameState<'bldr>> {
                let mut builder = DesiredGameStateBuilder::new(_fbb);
                if let Some(x) = args.boostStates {
                    builder.add_boostStates(x);
                }
                if let Some(x) = args.carStates {
                    builder.add_carStates(x);
                }
                if let Some(x) = args.ballState {
                    builder.add_ballState(x);
                }
                builder.finish()
            }

            pub const VT_BALLSTATE: flatbuffers::VOffsetT = 4;
            pub const VT_CARSTATES: flatbuffers::VOffsetT = 6;
            pub const VT_BOOSTSTATES: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn ballState(&'a self) -> Option<DesiredBallState<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<DesiredBallState<'a>>>(
                        DesiredGameState::VT_BALLSTATE,
                        None,
                    )
            }
            #[inline]
            pub fn carStates(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>,
                >>(DesiredGameState::VT_CARSTATES, None)
            }
            #[inline]
            pub fn boostStates(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>,
                >>(DesiredGameState::VT_BOOSTSTATES, None)
            }
        }

        pub struct DesiredGameStateArgs<'a> {
            pub ballState: Option<flatbuffers::WIPOffset<DesiredBallState<'a>>>,
            pub carStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>,
                >,
            >,
            pub boostStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>,
                >,
            >,
        }
        impl<'a> Default for DesiredGameStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredGameStateArgs {
                    ballState: None,
                    carStates: None,
                    boostStates: None,
                }
            }
        }
        pub struct DesiredGameStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredGameStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_ballState(
                &mut self,
                ballState: flatbuffers::WIPOffset<DesiredBallState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredBallState>>(
                        DesiredGameState::VT_BALLSTATE,
                        ballState,
                    );
            }
            #[inline]
            pub fn add_carStates(
                &mut self,
                carStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DesiredCarState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DesiredGameState::VT_CARSTATES,
                    carStates,
                );
            }
            #[inline]
            pub fn add_boostStates(
                &mut self,
                boostStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DesiredBoostState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DesiredGameState::VT_BOOSTSTATES,
                    boostStates,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredGameStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredGameStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredGameState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum ColorOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct Color<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Color<'a> {
            type Inner = Color<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> Color<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Color { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ColorArgs,
            ) -> flatbuffers::WIPOffset<Color<'bldr>> {
                let mut builder = ColorBuilder::new(_fbb);
                builder.add_b(args.b);
                builder.add_g(args.g);
                builder.add_r(args.r);
                builder.add_a(args.a);
                builder.finish()
            }

            pub const VT_A: flatbuffers::VOffsetT = 4;
            pub const VT_R: flatbuffers::VOffsetT = 6;
            pub const VT_G: flatbuffers::VOffsetT = 8;
            pub const VT_B: flatbuffers::VOffsetT = 10;

            #[inline]
            pub fn a(&'a self) -> u8 {
                self._tab.get::<u8>(Color::VT_A, Some(0)).unwrap()
            }
            #[inline]
            pub fn r(&'a self) -> u8 {
                self._tab.get::<u8>(Color::VT_R, Some(0)).unwrap()
            }
            #[inline]
            pub fn g(&'a self) -> u8 {
                self._tab.get::<u8>(Color::VT_G, Some(0)).unwrap()
            }
            #[inline]
            pub fn b(&'a self) -> u8 {
                self._tab.get::<u8>(Color::VT_B, Some(0)).unwrap()
            }
        }

        pub struct ColorArgs {
            pub a: u8,
            pub r: u8,
            pub g: u8,
            pub b: u8,
        }
        impl<'a> Default for ColorArgs {
            #[inline]
            fn default() -> Self {
                ColorArgs {
                    a: 0,
                    r: 0,
                    g: 0,
                    b: 0,
                }
            }
        }
        pub struct ColorBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ColorBuilder<'a, 'b> {
            #[inline]
            pub fn add_a(&mut self, a: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_A, a, 0);
            }
            #[inline]
            pub fn add_r(&mut self, r: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_R, r, 0);
            }
            #[inline]
            pub fn add_g(&mut self, g: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_G, g, 0);
            }
            #[inline]
            pub fn add_b(&mut self, b: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_B, b, 0);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColorBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ColorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Color<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum RenderMessageOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RenderMessage<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RenderMessage<'a> {
            type Inner = RenderMessage<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RenderMessage<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RenderMessage { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RenderMessageArgs<'args>,
            ) -> flatbuffers::WIPOffset<RenderMessage<'bldr>> {
                let mut builder = RenderMessageBuilder::new(_fbb);
                if let Some(x) = args.text {
                    builder.add_text(x);
                }
                builder.add_scaleY(args.scaleY);
                builder.add_scaleX(args.scaleX);
                if let Some(x) = args.end {
                    builder.add_end(x);
                }
                if let Some(x) = args.start {
                    builder.add_start(x);
                }
                if let Some(x) = args.color {
                    builder.add_color(x);
                }
                builder.add_isFilled(args.isFilled);
                builder.add_renderType(args.renderType);
                builder.finish()
            }

            pub const VT_RENDERTYPE: flatbuffers::VOffsetT = 4;
            pub const VT_COLOR: flatbuffers::VOffsetT = 6;
            pub const VT_START: flatbuffers::VOffsetT = 8;
            pub const VT_END: flatbuffers::VOffsetT = 10;
            pub const VT_SCALEX: flatbuffers::VOffsetT = 12;
            pub const VT_SCALEY: flatbuffers::VOffsetT = 14;
            pub const VT_TEXT: flatbuffers::VOffsetT = 16;
            pub const VT_ISFILLED: flatbuffers::VOffsetT = 18;

            #[inline]
            pub fn renderType(&'a self) -> RenderType {
                self._tab
                    .get::<RenderType>(RenderMessage::VT_RENDERTYPE, Some(RenderType::DrawLine2D))
                    .unwrap()
            }
            #[inline]
            pub fn color(&'a self) -> Option<Color<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Color<'a>>>(RenderMessage::VT_COLOR, None)
            }
            /// For 2d renders this only grabs x and y
            #[inline]
            pub fn start(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(RenderMessage::VT_START, None)
            }
            /// For 2d renders this only grabs x and y
            #[inline]
            pub fn end(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(RenderMessage::VT_END, None)
            }
            /// Scales the x size of the text/rectangle, is used for rectangles
            /// assuming an initial value of 1
            #[inline]
            pub fn scaleX(&'a self) -> i32 {
                self._tab
                    .get::<i32>(RenderMessage::VT_SCALEX, Some(1))
                    .unwrap()
            }
            /// Scales the y size of the text/rectangle, is used for rectangles
            /// assuming an initial value of 1
            #[inline]
            pub fn scaleY(&'a self) -> i32 {
                self._tab
                    .get::<i32>(RenderMessage::VT_SCALEY, Some(1))
                    .unwrap()
            }
            #[inline]
            pub fn text(&'a self) -> Option<&'a str> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(RenderMessage::VT_TEXT, None)
            }
            /// Rectangles can be filled or just outlines.
            #[inline]
            pub fn isFilled(&'a self) -> bool {
                self._tab
                    .get::<bool>(RenderMessage::VT_ISFILLED, Some(false))
                    .unwrap()
            }
        }

        pub struct RenderMessageArgs<'a> {
            pub renderType: RenderType,
            pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
            pub start: Option<&'a Vector3>,
            pub end: Option<&'a Vector3>,
            pub scaleX: i32,
            pub scaleY: i32,
            pub text: Option<flatbuffers::WIPOffset<&'a str>>,
            pub isFilled: bool,
        }
        impl<'a> Default for RenderMessageArgs<'a> {
            #[inline]
            fn default() -> Self {
                RenderMessageArgs {
                    renderType: RenderType::DrawLine2D,
                    color: None,
                    start: None,
                    end: None,
                    scaleX: 1,
                    scaleY: 1,
                    text: None,
                    isFilled: false,
                }
            }
        }
        pub struct RenderMessageBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RenderMessageBuilder<'a, 'b> {
            #[inline]
            pub fn add_renderType(&mut self, renderType: RenderType) {
                self.fbb_.push_slot::<RenderType>(
                    RenderMessage::VT_RENDERTYPE,
                    renderType,
                    RenderType::DrawLine2D,
                );
            }
            #[inline]
            pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b>>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(
                    RenderMessage::VT_COLOR,
                    color,
                );
            }
            #[inline]
            pub fn add_start(&mut self, start: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RenderMessage::VT_START, start);
            }
            #[inline]
            pub fn add_end(&mut self, end: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RenderMessage::VT_END, end);
            }
            #[inline]
            pub fn add_scaleX(&mut self, scaleX: i32) {
                self.fbb_
                    .push_slot::<i32>(RenderMessage::VT_SCALEX, scaleX, 1);
            }
            #[inline]
            pub fn add_scaleY(&mut self, scaleY: i32) {
                self.fbb_
                    .push_slot::<i32>(RenderMessage::VT_SCALEY, scaleY, 1);
            }
            #[inline]
            pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(RenderMessage::VT_TEXT, text);
            }
            #[inline]
            pub fn add_isFilled(&mut self, isFilled: bool) {
                self.fbb_
                    .push_slot::<bool>(RenderMessage::VT_ISFILLED, isFilled, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RenderMessageBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RenderMessageBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RenderMessage<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum RenderGroupOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct RenderGroup<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RenderGroup<'a> {
            type Inner = RenderGroup<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> RenderGroup<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RenderGroup { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RenderGroupArgs<'args>,
            ) -> flatbuffers::WIPOffset<RenderGroup<'bldr>> {
                let mut builder = RenderGroupBuilder::new(_fbb);
                builder.add_id(args.id);
                if let Some(x) = args.renderMessages {
                    builder.add_renderMessages(x);
                }
                builder.finish()
            }

            pub const VT_RENDERMESSAGES: flatbuffers::VOffsetT = 4;
            pub const VT_ID: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn renderMessages(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RenderMessage<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<RenderMessage<'a>>>,
                >>(RenderGroup::VT_RENDERMESSAGES, None)
            }
            /// The id of the render group
            #[inline]
            pub fn id(&'a self) -> i32 {
                self._tab.get::<i32>(RenderGroup::VT_ID, Some(0)).unwrap()
            }
        }

        pub struct RenderGroupArgs<'a> {
            pub renderMessages: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RenderMessage<'a>>>,
                >,
            >,
            pub id: i32,
        }
        impl<'a> Default for RenderGroupArgs<'a> {
            #[inline]
            fn default() -> Self {
                RenderGroupArgs {
                    renderMessages: None,
                    id: 0,
                }
            }
        }
        pub struct RenderGroupBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RenderGroupBuilder<'a, 'b> {
            #[inline]
            pub fn add_renderMessages(
                &mut self,
                renderMessages: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RenderMessage<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    RenderGroup::VT_RENDERMESSAGES,
                    renderMessages,
                );
            }
            #[inline]
            pub fn add_id(&mut self, id: i32) {
                self.fbb_.push_slot::<i32>(RenderGroup::VT_ID, id, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RenderGroupBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RenderGroupBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RenderGroup<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum QuickChatOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct QuickChat<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for QuickChat<'a> {
            type Inner = QuickChat<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> QuickChat<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                QuickChat { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args QuickChatArgs,
            ) -> flatbuffers::WIPOffset<QuickChat<'bldr>> {
                let mut builder = QuickChatBuilder::new(_fbb);
                builder.add_playerIndex(args.playerIndex);
                builder.add_teamOnly(args.teamOnly);
                builder.add_quickChatSelection(args.quickChatSelection);
                builder.finish()
            }

            pub const VT_QUICKCHATSELECTION: flatbuffers::VOffsetT = 4;
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 6;
            pub const VT_TEAMONLY: flatbuffers::VOffsetT = 8;

            #[inline]
            pub fn quickChatSelection(&'a self) -> QuickChatSelection {
                self._tab
                    .get::<QuickChatSelection>(
                        QuickChat::VT_QUICKCHATSELECTION,
                        Some(QuickChatSelection::Information_IGotIt),
                    ).unwrap()
            }
            /// The index of the player that sent the quick chat
            #[inline]
            pub fn playerIndex(&'a self) -> i32 {
                self._tab
                    .get::<i32>(QuickChat::VT_PLAYERINDEX, Some(0))
                    .unwrap()
            }
            /// True if the chat is team only false if everyone can see it.
            #[inline]
            pub fn teamOnly(&'a self) -> bool {
                self._tab
                    .get::<bool>(QuickChat::VT_TEAMONLY, Some(false))
                    .unwrap()
            }
        }

        pub struct QuickChatArgs {
            pub quickChatSelection: QuickChatSelection,
            pub playerIndex: i32,
            pub teamOnly: bool,
        }
        impl<'a> Default for QuickChatArgs {
            #[inline]
            fn default() -> Self {
                QuickChatArgs {
                    quickChatSelection: QuickChatSelection::Information_IGotIt,
                    playerIndex: 0,
                    teamOnly: false,
                }
            }
        }
        pub struct QuickChatBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> QuickChatBuilder<'a, 'b> {
            #[inline]
            pub fn add_quickChatSelection(&mut self, quickChatSelection: QuickChatSelection) {
                self.fbb_.push_slot::<QuickChatSelection>(
                    QuickChat::VT_QUICKCHATSELECTION,
                    quickChatSelection,
                    QuickChatSelection::Information_IGotIt,
                );
            }
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(QuickChat::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn add_teamOnly(&mut self, teamOnly: bool) {
                self.fbb_
                    .push_slot::<bool>(QuickChat::VT_TEAMONLY, teamOnly, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> QuickChatBuilder<'a, 'b> {
                let start = _fbb.start_table();
                QuickChatBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<QuickChat<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A minimal version of player data, useful when bandwidth needs to be
        /// conserved.
        pub enum TinyPlayerOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct TinyPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyPlayer<'a> {
            type Inner = TinyPlayer<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> TinyPlayer<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyPlayerArgs,
            ) -> flatbuffers::WIPOffset<TinyPlayer<'bldr>> {
                let mut builder = TinyPlayerBuilder::new(_fbb);
                builder.add_boost(args.boost);
                builder.add_team(args.team);
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_isSupersonic(args.isSupersonic);
                builder.add_hasWheelContact(args.hasWheelContact);
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_HASWHEELCONTACT: flatbuffers::VOffsetT = 10;
            pub const VT_ISSUPERSONIC: flatbuffers::VOffsetT = 12;
            pub const VT_TEAM: flatbuffers::VOffsetT = 14;
            pub const VT_BOOST: flatbuffers::VOffsetT = 16;

            #[inline]
            pub fn location(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(TinyPlayer::VT_LOCATION, None)
            }
            #[inline]
            pub fn rotation(&'a self) -> Option<&'a Rotator> {
                self._tab.get::<Rotator>(TinyPlayer::VT_ROTATION, None)
            }
            #[inline]
            pub fn velocity(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(TinyPlayer::VT_VELOCITY, None)
            }
            #[inline]
            pub fn hasWheelContact(&'a self) -> bool {
                self._tab
                    .get::<bool>(TinyPlayer::VT_HASWHEELCONTACT, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn isSupersonic(&'a self) -> bool {
                self._tab
                    .get::<bool>(TinyPlayer::VT_ISSUPERSONIC, Some(false))
                    .unwrap()
            }
            #[inline]
            pub fn team(&'a self) -> i32 {
                self._tab.get::<i32>(TinyPlayer::VT_TEAM, Some(0)).unwrap()
            }
            #[inline]
            pub fn boost(&'a self) -> i32 {
                self._tab.get::<i32>(TinyPlayer::VT_BOOST, Some(0)).unwrap()
            }
        }

        pub struct TinyPlayerArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub rotation: Option<&'a Rotator>,
            pub velocity: Option<&'a Vector3>,
            pub hasWheelContact: bool,
            pub isSupersonic: bool,
            pub team: i32,
            pub boost: i32,
        }
        impl<'a> Default for TinyPlayerArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyPlayerArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    hasWheelContact: false,
                    isSupersonic: false,
                    team: 0,
                    boost: 0,
                }
            }
        }
        pub struct TinyPlayerBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyPlayer::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: &'b Rotator) {
                self.fbb_
                    .push_slot_always::<&Rotator>(TinyPlayer::VT_ROTATION, rotation);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyPlayer::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn add_hasWheelContact(&mut self, hasWheelContact: bool) {
                self.fbb_
                    .push_slot::<bool>(TinyPlayer::VT_HASWHEELCONTACT, hasWheelContact, false);
            }
            #[inline]
            pub fn add_isSupersonic(&mut self, isSupersonic: bool) {
                self.fbb_
                    .push_slot::<bool>(TinyPlayer::VT_ISSUPERSONIC, isSupersonic, false);
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_.push_slot::<i32>(TinyPlayer::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: i32) {
                self.fbb_.push_slot::<i32>(TinyPlayer::VT_BOOST, boost, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A minimal version of the ball, useful when bandwidth needs to be
        /// conserved.
        pub enum TinyBallOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct TinyBall<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyBall<'a> {
            type Inner = TinyBall<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> TinyBall<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyBall { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyBallArgs,
            ) -> flatbuffers::WIPOffset<TinyBall<'bldr>> {
                let mut builder = TinyBallBuilder::new(_fbb);
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn location(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(TinyBall::VT_LOCATION, None)
            }
            #[inline]
            pub fn velocity(&'a self) -> Option<&'a Vector3> {
                self._tab.get::<Vector3>(TinyBall::VT_VELOCITY, None)
            }
        }

        pub struct TinyBallArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub velocity: Option<&'a Vector3>,
        }
        impl<'a> Default for TinyBallArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyBallArgs {
                    location: None,
                    velocity: None,
                }
            }
        }
        pub struct TinyBallBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyBallBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyBall::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &'b Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyBall::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyBallBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyBallBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyBall<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        /// A minimal version of the game tick packet, useful when bandwidth
        /// needs to be conserved.
        pub enum TinyPacketOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct TinyPacket<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyPacket<'a> {
            type Inner = TinyPacket<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> TinyPacket<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyPacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyPacketArgs<'args>,
            ) -> flatbuffers::WIPOffset<TinyPacket<'bldr>> {
                let mut builder = TinyPacketBuilder::new(_fbb);
                if let Some(x) = args.ball {
                    builder.add_ball(x);
                }
                if let Some(x) = args.players {
                    builder.add_players(x);
                }
                builder.finish()
            }

            pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;
            pub const VT_BALL: flatbuffers::VOffsetT = 6;

            #[inline]
            pub fn players(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>,
                >>(TinyPacket::VT_PLAYERS, None)
            }
            #[inline]
            pub fn ball(&'a self) -> Option<TinyBall<'a>> {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<TinyBall<'a>>>(TinyPacket::VT_BALL, None)
            }
        }

        pub struct TinyPacketArgs<'a> {
            pub players: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>,
                >,
            >,
            pub ball: Option<flatbuffers::WIPOffset<TinyBall<'a>>>,
        }
        impl<'a> Default for TinyPacketArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyPacketArgs {
                    players: None,
                    ball: None,
                }
            }
        }
        pub struct TinyPacketBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyPacketBuilder<'a, 'b> {
            #[inline]
            pub fn add_players(
                &mut self,
                players: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TinyPlayer<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TinyPacket::VT_PLAYERS, players);
            }
            #[inline]
            pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<TinyBall<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TinyBall>>(
                        TinyPacket::VT_BALL,
                        ball,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyPacketBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyPacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyPacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum PredictionSliceOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct PredictionSlice<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PredictionSlice<'a> {
            type Inner = PredictionSlice<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> PredictionSlice<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PredictionSlice { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PredictionSliceArgs,
            ) -> flatbuffers::WIPOffset<PredictionSlice<'bldr>> {
                let mut builder = PredictionSliceBuilder::new(_fbb);
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.add_gameSeconds(args.gameSeconds);
                builder.finish()
            }

            pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 4;
            pub const VT_PHYSICS: flatbuffers::VOffsetT = 6;

            /// The moment in game time that this prediction corresponds to.
            /// This corresponds to 'secondsElapsed' in the GameInfo table.
            #[inline]
            pub fn gameSeconds(&'a self) -> f32 {
                self._tab
                    .get::<f32>(PredictionSlice::VT_GAMESECONDS, Some(0.0))
                    .unwrap()
            }
            /// The predicted location and motion of the object.
            #[inline]
            pub fn physics(&'a self) -> Option<Physics<'a>> {
                self._tab.get::<flatbuffers::ForwardsUOffset<Physics<'a>>>(
                    PredictionSlice::VT_PHYSICS,
                    None,
                )
            }
        }

        pub struct PredictionSliceArgs<'a> {
            pub gameSeconds: f32,
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
        }
        impl<'a> Default for PredictionSliceArgs<'a> {
            #[inline]
            fn default() -> Self {
                PredictionSliceArgs {
                    gameSeconds: 0.0,
                    physics: None,
                }
            }
        }
        pub struct PredictionSliceBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PredictionSliceBuilder<'a, 'b> {
            #[inline]
            pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
                self.fbb_
                    .push_slot::<f32>(PredictionSlice::VT_GAMESECONDS, gameSeconds, 0.0);
            }
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics>>(
                        PredictionSlice::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PredictionSliceBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PredictionSliceBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PredictionSlice<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        pub enum BallPredictionOffset {}
        #[derive(Copy, Clone, Debug, PartialEq)]

        pub struct BallPrediction<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BallPrediction<'a> {
            type Inner = BallPrediction<'a>;
            #[inline]
            fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table { buf, loc },
                }
            }
        }

        impl<'a> BallPrediction<'a> {
            #[inline]
            pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BallPrediction { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BallPredictionArgs<'args>,
            ) -> flatbuffers::WIPOffset<BallPrediction<'bldr>> {
                let mut builder = BallPredictionBuilder::new(_fbb);
                if let Some(x) = args.slices {
                    builder.add_slices(x);
                }
                builder.finish()
            }

            pub const VT_SLICES: flatbuffers::VOffsetT = 4;

            /// A list of places the ball will be at specific times in the
            /// future. It is guaranteed to sorted so that time
            /// increases with each slice. It is NOT guaranteed to
            /// have a consistent amount of time between slices.
            #[inline]
            pub fn slices(
                &'a self,
            ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>>
            {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>,
                >>(BallPrediction::VT_SLICES, None)
            }
        }

        pub struct BallPredictionArgs<'a> {
            pub slices: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>,
                >,
            >,
        }
        impl<'a> Default for BallPredictionArgs<'a> {
            #[inline]
            fn default() -> Self {
                BallPredictionArgs { slices: None }
            }
        }
        pub struct BallPredictionBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BallPredictionBuilder<'a, 'b> {
            #[inline]
            pub fn add_slices(
                &mut self,
                slices: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PredictionSlice<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    BallPrediction::VT_SLICES,
                    slices,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BallPredictionBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BallPredictionBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BallPrediction<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        #[inline]
        pub fn get_root_as_quick_chat<'a>(buf: &'a [u8]) -> QuickChat<'a> {
            flatbuffers::get_root::<QuickChat<'a>>(buf)
        }

        #[inline]
        pub fn get_size_prefixed_root_as_quick_chat<'a>(buf: &'a [u8]) -> QuickChat<'a> {
            flatbuffers::get_size_prefixed_root::<QuickChat<'a>>(buf)
        }

        #[inline]
        pub fn finish_quick_chat_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<QuickChat<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_quick_chat_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<QuickChat<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod flat
} // pub mod rlbot
